import {
  __commonJS,
  __require
} from "./chunk-WTEL7FPM.js";

// browser-external:dgram
var require_dgram = __commonJS({
  "browser-external:dgram"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "dgram" has been externalized for browser compatibility. Cannot access "dgram.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/long/src/long.js"(exports, module) {
    module.exports = Long2;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long2(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long2.prototype.__isLong__;
    Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long2.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long2.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long2.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long2(lowBits, highBits, unsigned);
    }
    Long2.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long2.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long2.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long2.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long2.UZERO = UZERO;
    var ONE = fromInt(1);
    Long2.ONE = ONE;
    var UONE = fromInt(1, true);
    Long2.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long2.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long2.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long2.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long2.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long2.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
    };
    Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long2(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long2(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// node_modules/osc/src/osc.js
var require_osc = __commonJS({
  "node_modules/osc/src/osc.js"(exports, module) {
    var osc = osc || {};
    (function() {
      "use strict";
      osc.SECS_70YRS = 2208988800;
      osc.TWO_32 = 4294967296;
      osc.defaults = {
        metadata: false,
        unpackSingleArgs: true
      };
      osc.isCommonJS = typeof module !== "undefined" && module.exports ? true : false;
      osc.isNode = osc.isCommonJS && typeof window === "undefined";
      osc.isElectron = typeof process !== "undefined" && process.versions && process.versions.electron ? true : false;
      osc.isBufferEnv = osc.isNode || osc.isElectron;
      osc.isArray = function(obj) {
        return obj && Object.prototype.toString.call(obj) === "[object Array]";
      };
      osc.isTypedArrayView = function(obj) {
        return obj.buffer && obj.buffer instanceof ArrayBuffer;
      };
      osc.isBuffer = function(obj) {
        return osc.isBufferEnv && obj instanceof Buffer;
      };
      osc.Long = typeof Long !== "undefined" ? Long : osc.isNode ? require_long() : void 0;
      osc.TextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8") : typeof util !== "undefined" && typeof (util.TextDecoder !== "undefined") ? new util.TextDecoder("utf-8") : void 0;
      osc.TextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : typeof util !== "undefined" && typeof (util.TextEncoder !== "undefined") ? new util.TextEncoder("utf-8") : void 0;
      osc.dataView = function(obj, offset, length) {
        if (obj.buffer) {
          return new DataView(obj.buffer, offset, length);
        }
        if (obj instanceof ArrayBuffer) {
          return new DataView(obj, offset, length);
        }
        return new DataView(new Uint8Array(obj), offset, length);
      };
      osc.byteArray = function(obj) {
        if (obj instanceof Uint8Array) {
          return obj;
        }
        var buf = obj.buffer ? obj.buffer : obj;
        if (!(buf instanceof ArrayBuffer) && (typeof buf.length === "undefined" || typeof buf === "string")) {
          throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " + JSON.stringify(obj, null, 2));
        }
        return new Uint8Array(buf);
      };
      osc.nativeBuffer = function(obj) {
        if (osc.isBufferEnv) {
          return osc.isBuffer(obj) ? obj : Buffer.from(obj.buffer ? obj : new Uint8Array(obj));
        }
        return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
      };
      osc.copyByteArray = function(source, target, offset) {
        if (osc.isTypedArrayView(source) && osc.isTypedArrayView(target)) {
          target.set(source, offset);
        } else {
          var start = offset === void 0 ? 0 : offset, len = Math.min(target.length - offset, source.length);
          for (var i = 0, j = start; i < len; i++, j++) {
            target[j] = source[i];
          }
        }
        return target;
      };
      osc.readString = function(dv, offsetState) {
        var charCodes = [], idx = offsetState.idx;
        for (; idx < dv.byteLength; idx++) {
          var charCode = dv.getUint8(idx);
          if (charCode !== 0) {
            charCodes.push(charCode);
          } else {
            idx++;
            break;
          }
        }
        idx = idx + 3 & ~3;
        offsetState.idx = idx;
        var decoder = osc.isBufferEnv ? osc.readString.withBuffer : osc.TextDecoder ? osc.readString.withTextDecoder : osc.readString.raw;
        return decoder(charCodes);
      };
      osc.readString.raw = function(charCodes) {
        var str = "";
        var sliceSize = 1e4;
        for (var i = 0; i < charCodes.length; i += sliceSize) {
          str += String.fromCharCode.apply(null, charCodes.slice(i, i + sliceSize));
        }
        return str;
      };
      osc.readString.withTextDecoder = function(charCodes) {
        var data = new Int8Array(charCodes);
        return osc.TextDecoder.decode(data);
      };
      osc.readString.withBuffer = function(charCodes) {
        return Buffer.from(charCodes).toString("utf-8");
      };
      osc.writeString = function(str) {
        var encoder = osc.isBufferEnv ? osc.writeString.withBuffer : osc.TextEncoder ? osc.writeString.withTextEncoder : null, terminated = str + "\0", encodedStr;
        if (encoder) {
          encodedStr = encoder(terminated);
        }
        var len = encoder ? encodedStr.length : terminated.length, paddedLen = len + 3 & ~3, arr = new Uint8Array(paddedLen);
        for (var i = 0; i < len - 1; i++) {
          var charCode = encoder ? encodedStr[i] : terminated.charCodeAt(i);
          arr[i] = charCode;
        }
        return arr;
      };
      osc.writeString.withTextEncoder = function(str) {
        return osc.TextEncoder.encode(str);
      };
      osc.writeString.withBuffer = function(str) {
        return Buffer.from(str);
      };
      osc.readPrimitive = function(dv, readerName, numBytes, offsetState) {
        var val = dv[readerName](offsetState.idx, false);
        offsetState.idx += numBytes;
        return val;
      };
      osc.writePrimitive = function(val, dv, writerName, numBytes, offset) {
        offset = offset === void 0 ? 0 : offset;
        var arr;
        if (!dv) {
          arr = new Uint8Array(numBytes);
          dv = new DataView(arr.buffer);
        } else {
          arr = new Uint8Array(dv.buffer);
        }
        dv[writerName](offset, val, false);
        return arr;
      };
      osc.readInt32 = function(dv, offsetState) {
        return osc.readPrimitive(dv, "getInt32", 4, offsetState);
      };
      osc.writeInt32 = function(val, dv, offset) {
        return osc.writePrimitive(val, dv, "setInt32", 4, offset);
      };
      osc.readInt64 = function(dv, offsetState) {
        var high = osc.readPrimitive(dv, "getInt32", 4, offsetState), low = osc.readPrimitive(dv, "getInt32", 4, offsetState);
        if (osc.Long) {
          return new osc.Long(low, high);
        } else {
          return {
            high,
            low,
            unsigned: false
          };
        }
      };
      osc.writeInt64 = function(val, dv, offset) {
        var arr = new Uint8Array(8);
        arr.set(osc.writePrimitive(val.high, dv, "setInt32", 4, offset), 0);
        arr.set(osc.writePrimitive(val.low, dv, "setInt32", 4, offset + 4), 4);
        return arr;
      };
      osc.readFloat32 = function(dv, offsetState) {
        return osc.readPrimitive(dv, "getFloat32", 4, offsetState);
      };
      osc.writeFloat32 = function(val, dv, offset) {
        return osc.writePrimitive(val, dv, "setFloat32", 4, offset);
      };
      osc.readFloat64 = function(dv, offsetState) {
        return osc.readPrimitive(dv, "getFloat64", 8, offsetState);
      };
      osc.writeFloat64 = function(val, dv, offset) {
        return osc.writePrimitive(val, dv, "setFloat64", 8, offset);
      };
      osc.readChar32 = function(dv, offsetState) {
        var charCode = osc.readPrimitive(dv, "getUint32", 4, offsetState);
        return String.fromCharCode(charCode);
      };
      osc.writeChar32 = function(str, dv, offset) {
        var charCode = str.charCodeAt(0);
        if (charCode === void 0 || charCode < -1) {
          return void 0;
        }
        return osc.writePrimitive(charCode, dv, "setUint32", 4, offset);
      };
      osc.readBlob = function(dv, offsetState) {
        var len = osc.readInt32(dv, offsetState), paddedLen = len + 3 & ~3, blob = new Uint8Array(dv.buffer, offsetState.idx, len);
        offsetState.idx += paddedLen;
        return blob;
      };
      osc.writeBlob = function(data) {
        data = osc.byteArray(data);
        var len = data.byteLength, paddedLen = len + 3 & ~3, offset = 4, blobLen = paddedLen + offset, arr = new Uint8Array(blobLen), dv = new DataView(arr.buffer);
        osc.writeInt32(len, dv);
        arr.set(data, offset);
        return arr;
      };
      osc.readMIDIBytes = function(dv, offsetState) {
        var midi = new Uint8Array(dv.buffer, offsetState.idx, 4);
        offsetState.idx += 4;
        return midi;
      };
      osc.writeMIDIBytes = function(bytes) {
        bytes = osc.byteArray(bytes);
        var arr = new Uint8Array(4);
        arr.set(bytes);
        return arr;
      };
      osc.readColor = function(dv, offsetState) {
        var bytes = new Uint8Array(dv.buffer, offsetState.idx, 4), alpha = bytes[3] / 255;
        offsetState.idx += 4;
        return {
          r: bytes[0],
          g: bytes[1],
          b: bytes[2],
          a: alpha
        };
      };
      osc.writeColor = function(color) {
        var alpha = Math.round(color.a * 255), arr = new Uint8Array([color.r, color.g, color.b, alpha]);
        return arr;
      };
      osc.readTrue = function() {
        return true;
      };
      osc.readFalse = function() {
        return false;
      };
      osc.readNull = function() {
        return null;
      };
      osc.readImpulse = function() {
        return 1;
      };
      osc.readTimeTag = function(dv, offsetState) {
        var secs1900 = osc.readPrimitive(dv, "getUint32", 4, offsetState), frac = osc.readPrimitive(dv, "getUint32", 4, offsetState), native = secs1900 === 0 && frac === 1 ? Date.now() : osc.ntpToJSTime(secs1900, frac);
        return {
          raw: [secs1900, frac],
          native
        };
      };
      osc.writeTimeTag = function(timeTag) {
        var raw = timeTag.raw ? timeTag.raw : osc.jsToNTPTime(timeTag.native), arr = new Uint8Array(8), dv = new DataView(arr.buffer);
        osc.writeInt32(raw[0], dv, 0);
        osc.writeInt32(raw[1], dv, 4);
        return arr;
      };
      osc.timeTag = function(secs, now) {
        secs = secs || 0;
        now = now || Date.now();
        var nowSecs = now / 1e3, nowWhole = Math.floor(nowSecs), nowFracs = nowSecs - nowWhole, secsWhole = Math.floor(secs), secsFracs = secs - secsWhole, fracs = nowFracs + secsFracs;
        if (fracs > 1) {
          var fracsWhole = Math.floor(fracs), fracsFracs = fracs - fracsWhole;
          secsWhole += fracsWhole;
          fracs = fracsFracs;
        }
        var ntpSecs = nowWhole + secsWhole + osc.SECS_70YRS, ntpFracs = Math.round(osc.TWO_32 * fracs);
        return {
          raw: [ntpSecs, ntpFracs]
        };
      };
      osc.ntpToJSTime = function(secs1900, frac) {
        var secs1970 = secs1900 - osc.SECS_70YRS, decimals = frac / osc.TWO_32, msTime = (secs1970 + decimals) * 1e3;
        return msTime;
      };
      osc.jsToNTPTime = function(jsTime) {
        var secs = jsTime / 1e3, secsWhole = Math.floor(secs), secsFrac = secs - secsWhole, ntpSecs = secsWhole + osc.SECS_70YRS, ntpFracs = Math.round(osc.TWO_32 * secsFrac);
        return [ntpSecs, ntpFracs];
      };
      osc.readArguments = function(dv, options, offsetState) {
        var typeTagString = osc.readString(dv, offsetState);
        if (typeTagString.indexOf(",") !== 0) {
          throw new Error("A malformed type tag string was found while reading the arguments of an OSC message. String was: " + typeTagString, " at offset: " + offsetState.idx);
        }
        var argTypes = typeTagString.substring(1).split(""), args = [];
        osc.readArgumentsIntoArray(args, argTypes, typeTagString, dv, options, offsetState);
        return args;
      };
      osc.readArgument = function(argType, typeTagString, dv, options, offsetState) {
        var typeSpec = osc.argumentTypes[argType];
        if (!typeSpec) {
          throw new Error("'" + argType + "' is not a valid OSC type tag. Type tag string was: " + typeTagString);
        }
        var argReader = typeSpec.reader, arg = osc[argReader](dv, offsetState);
        if (options.metadata) {
          arg = {
            type: argType,
            value: arg
          };
        }
        return arg;
      };
      osc.readArgumentsIntoArray = function(arr, argTypes, typeTagString, dv, options, offsetState) {
        var i = 0;
        while (i < argTypes.length) {
          var argType = argTypes[i], arg;
          if (argType === "[") {
            var fromArrayOpen = argTypes.slice(i + 1), endArrayIdx = fromArrayOpen.indexOf("]");
            if (endArrayIdx < 0) {
              throw new Error("Invalid argument type tag: an open array type tag ('[') was found without a matching close array tag ('[]'). Type tag was: " + typeTagString);
            }
            var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
            arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
            i += endArrayIdx + 2;
          } else {
            arg = osc.readArgument(argType, typeTagString, dv, options, offsetState);
            i++;
          }
          arr.push(arg);
        }
        return arr;
      };
      osc.writeArguments = function(args, options) {
        var argCollection = osc.collectArguments(args, options);
        return osc.joinParts(argCollection);
      };
      osc.joinParts = function(dataCollection) {
        var buf = new Uint8Array(dataCollection.byteLength), parts = dataCollection.parts, offset = 0;
        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          osc.copyByteArray(part, buf, offset);
          offset += part.length;
        }
        return buf;
      };
      osc.addDataPart = function(dataPart, dataCollection) {
        dataCollection.parts.push(dataPart);
        dataCollection.byteLength += dataPart.length;
      };
      osc.writeArrayArguments = function(args, dataCollection) {
        var typeTag = "[";
        for (var i = 0; i < args.length; i++) {
          var arg = args[i];
          typeTag += osc.writeArgument(arg, dataCollection);
        }
        typeTag += "]";
        return typeTag;
      };
      osc.writeArgument = function(arg, dataCollection) {
        if (osc.isArray(arg)) {
          return osc.writeArrayArguments(arg, dataCollection);
        }
        var type = arg.type, writer = osc.argumentTypes[type].writer;
        if (writer) {
          var data = osc[writer](arg.value);
          osc.addDataPart(data, dataCollection);
        }
        return arg.type;
      };
      osc.collectArguments = function(args, options, dataCollection) {
        if (!osc.isArray(args)) {
          args = typeof args === "undefined" ? [] : [args];
        }
        dataCollection = dataCollection || {
          byteLength: 0,
          parts: []
        };
        if (!options.metadata) {
          args = osc.annotateArguments(args);
        }
        var typeTagString = ",", currPartIdx = dataCollection.parts.length;
        for (var i = 0; i < args.length; i++) {
          var arg = args[i];
          typeTagString += osc.writeArgument(arg, dataCollection);
        }
        var typeData = osc.writeString(typeTagString);
        dataCollection.byteLength += typeData.byteLength;
        dataCollection.parts.splice(currPartIdx, 0, typeData);
        return dataCollection;
      };
      osc.readMessage = function(data, options, offsetState) {
        options = options || osc.defaults;
        var dv = osc.dataView(data, data.byteOffset, data.byteLength);
        offsetState = offsetState || {
          idx: 0
        };
        var address = osc.readString(dv, offsetState);
        return osc.readMessageContents(address, dv, options, offsetState);
      };
      osc.readMessageContents = function(address, dv, options, offsetState) {
        if (address.indexOf("/") !== 0) {
          throw new Error("A malformed OSC address was found while reading an OSC message. String was: " + address);
        }
        var args = osc.readArguments(dv, options, offsetState);
        return {
          address,
          args: args.length === 1 && options.unpackSingleArgs ? args[0] : args
        };
      };
      osc.collectMessageParts = function(msg, options, dataCollection) {
        dataCollection = dataCollection || {
          byteLength: 0,
          parts: []
        };
        osc.addDataPart(osc.writeString(msg.address), dataCollection);
        return osc.collectArguments(msg.args, options, dataCollection);
      };
      osc.writeMessage = function(msg, options) {
        options = options || osc.defaults;
        if (!osc.isValidMessage(msg)) {
          throw new Error("An OSC message must contain a valid address. Message was: " + JSON.stringify(msg, null, 2));
        }
        var msgCollection = osc.collectMessageParts(msg, options);
        return osc.joinParts(msgCollection);
      };
      osc.isValidMessage = function(msg) {
        return msg.address && msg.address.indexOf("/") === 0;
      };
      osc.readBundle = function(dv, options, offsetState) {
        return osc.readPacket(dv, options, offsetState);
      };
      osc.collectBundlePackets = function(bundle, options, dataCollection) {
        dataCollection = dataCollection || {
          byteLength: 0,
          parts: []
        };
        osc.addDataPart(osc.writeString("#bundle"), dataCollection);
        osc.addDataPart(osc.writeTimeTag(bundle.timeTag), dataCollection);
        for (var i = 0; i < bundle.packets.length; i++) {
          var packet = bundle.packets[i], collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets, packetCollection = collector(packet, options);
          dataCollection.byteLength += packetCollection.byteLength;
          osc.addDataPart(osc.writeInt32(packetCollection.byteLength), dataCollection);
          dataCollection.parts = dataCollection.parts.concat(packetCollection.parts);
        }
        return dataCollection;
      };
      osc.writeBundle = function(bundle, options) {
        if (!osc.isValidBundle(bundle)) {
          throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. Bundle was: " + JSON.stringify(bundle, null, 2));
        }
        options = options || osc.defaults;
        var bundleCollection = osc.collectBundlePackets(bundle, options);
        return osc.joinParts(bundleCollection);
      };
      osc.isValidBundle = function(bundle) {
        return bundle.timeTag !== void 0 && bundle.packets !== void 0;
      };
      osc.readBundleContents = function(dv, options, offsetState, len) {
        var timeTag = osc.readTimeTag(dv, offsetState), packets = [];
        while (offsetState.idx < len) {
          var packetSize = osc.readInt32(dv, offsetState), packetLen = offsetState.idx + packetSize, packet = osc.readPacket(dv, options, offsetState, packetLen);
          packets.push(packet);
        }
        return {
          timeTag,
          packets
        };
      };
      osc.readPacket = function(data, options, offsetState, len) {
        var dv = osc.dataView(data, data.byteOffset, data.byteLength);
        len = len === void 0 ? dv.byteLength : len;
        offsetState = offsetState || {
          idx: 0
        };
        var header = osc.readString(dv, offsetState), firstChar = header[0];
        if (firstChar === "#") {
          return osc.readBundleContents(dv, options, offsetState, len);
        } else if (firstChar === "/") {
          return osc.readMessageContents(header, dv, options, offsetState);
        }
        throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string. Header was: " + header);
      };
      osc.writePacket = function(packet, options) {
        if (osc.isValidMessage(packet)) {
          return osc.writeMessage(packet, options);
        } else if (osc.isValidBundle(packet)) {
          return osc.writeBundle(packet, options);
        } else {
          throw new Error("The specified packet was not recognized as a valid OSC message or bundle. Packet was: " + JSON.stringify(packet, null, 2));
        }
      };
      osc.argumentTypes = {
        i: {
          reader: "readInt32",
          writer: "writeInt32"
        },
        h: {
          reader: "readInt64",
          writer: "writeInt64"
        },
        f: {
          reader: "readFloat32",
          writer: "writeFloat32"
        },
        s: {
          reader: "readString",
          writer: "writeString"
        },
        S: {
          reader: "readString",
          writer: "writeString"
        },
        b: {
          reader: "readBlob",
          writer: "writeBlob"
        },
        t: {
          reader: "readTimeTag",
          writer: "writeTimeTag"
        },
        T: {
          reader: "readTrue"
        },
        F: {
          reader: "readFalse"
        },
        N: {
          reader: "readNull"
        },
        I: {
          reader: "readImpulse"
        },
        d: {
          reader: "readFloat64",
          writer: "writeFloat64"
        },
        c: {
          reader: "readChar32",
          writer: "writeChar32"
        },
        r: {
          reader: "readColor",
          writer: "writeColor"
        },
        m: {
          reader: "readMIDIBytes",
          writer: "writeMIDIBytes"
        }
        // [] are special cased within read/writeArguments()
      };
      osc.inferTypeForArgument = function(arg) {
        var type = typeof arg;
        switch (type) {
          case "boolean":
            return arg ? "T" : "F";
          case "string":
            return "s";
          case "number":
            return "f";
          case "undefined":
            return "N";
          case "object":
            if (arg === null) {
              return "N";
            } else if (arg instanceof Uint8Array || arg instanceof ArrayBuffer) {
              return "b";
            } else if (typeof arg.high === "number" && typeof arg.low === "number") {
              return "h";
            }
            break;
        }
        throw new Error("Can't infer OSC argument type for value: " + JSON.stringify(arg, null, 2));
      };
      osc.annotateArguments = function(args) {
        var annotated = [];
        for (var i = 0; i < args.length; i++) {
          var arg = args[i], msgArg;
          if (typeof arg === "object" && arg.type && arg.value !== void 0) {
            msgArg = arg;
          } else if (osc.isArray(arg)) {
            msgArg = osc.annotateArguments(arg);
          } else {
            var oscType = osc.inferTypeForArgument(arg);
            msgArg = {
              type: oscType,
              value: arg
            };
          }
          annotated.push(msgArg);
        }
        return annotated;
      };
      if (osc.isCommonJS) {
        module.exports = osc;
      }
    })();
  }
});

// node_modules/slip/src/slip.js
var require_slip = __commonJS({
  "node_modules/slip/src/slip.js"(exports) {
    (function(root, factory) {
      "use strict";
      if (typeof exports === "object") {
        root.slip = exports;
        factory(exports);
      } else if (typeof define === "function" && define.amd) {
        define(["exports"], function(exports2) {
          root.slip = exports2;
          return root.slip, factory(exports2);
        });
      } else {
        root.slip = {};
        factory(root.slip);
      }
    })(exports, function(exports2) {
      "use strict";
      var slip = exports2;
      slip.END = 192;
      slip.ESC = 219;
      slip.ESC_END = 220;
      slip.ESC_ESC = 221;
      slip.byteArray = function(data, offset, length) {
        return data instanceof ArrayBuffer ? new Uint8Array(data, offset, length) : data;
      };
      slip.expandByteArray = function(arr) {
        var expanded = new Uint8Array(arr.length * 2);
        expanded.set(arr);
        return expanded;
      };
      slip.sliceByteArray = function(arr, start, end) {
        var sliced = arr.buffer.slice ? arr.buffer.slice(start, end) : arr.subarray(start, end);
        return new Uint8Array(sliced);
      };
      slip.encode = function(data, o) {
        o = o || {};
        o.bufferPadding = o.bufferPadding || 4;
        data = slip.byteArray(data, o.offset, o.byteLength);
        var bufLen = data.length + o.bufferPadding + 3 & ~3, encoded = new Uint8Array(bufLen), j = 1;
        encoded[0] = slip.END;
        for (var i = 0; i < data.length; i++) {
          if (j > encoded.length - 3) {
            encoded = slip.expandByteArray(encoded);
          }
          var val = data[i];
          if (val === slip.END) {
            encoded[j++] = slip.ESC;
            val = slip.ESC_END;
          } else if (val === slip.ESC) {
            encoded[j++] = slip.ESC;
            val = slip.ESC_ESC;
          }
          encoded[j++] = val;
        }
        encoded[j] = slip.END;
        return slip.sliceByteArray(encoded, 0, j + 1);
      };
      slip.Decoder = function(o) {
        o = typeof o !== "function" ? o || {} : {
          onMessage: o
        };
        this.maxMessageSize = o.maxMessageSize || 10485760;
        this.bufferSize = o.bufferSize || 1024;
        this.msgBuffer = new Uint8Array(this.bufferSize);
        this.msgBufferIdx = 0;
        this.onMessage = o.onMessage;
        this.onError = o.onError;
        this.escape = false;
      };
      var p = slip.Decoder.prototype;
      p.decode = function(data) {
        data = slip.byteArray(data);
        var msg;
        for (var i = 0; i < data.length; i++) {
          var val = data[i];
          if (this.escape) {
            if (val === slip.ESC_ESC) {
              val = slip.ESC;
            } else if (val === slip.ESC_END) {
              val = slip.END;
            }
          } else {
            if (val === slip.ESC) {
              this.escape = true;
              continue;
            }
            if (val === slip.END) {
              msg = this.handleEnd();
              continue;
            }
          }
          var more = this.addByte(val);
          if (!more) {
            this.handleMessageMaxError();
          }
        }
        return msg;
      };
      p.handleMessageMaxError = function() {
        if (this.onError) {
          this.onError(
            this.msgBuffer.subarray(0),
            "The message is too large; the maximum message size is " + this.maxMessageSize / 1024 + "KB. Use a larger maxMessageSize if necessary."
          );
        }
        this.msgBufferIdx = 0;
        this.escape = false;
      };
      p.addByte = function(val) {
        if (this.msgBufferIdx > this.msgBuffer.length - 1) {
          this.msgBuffer = slip.expandByteArray(this.msgBuffer);
        }
        this.msgBuffer[this.msgBufferIdx++] = val;
        this.escape = false;
        return this.msgBuffer.length < this.maxMessageSize;
      };
      p.handleEnd = function() {
        if (this.msgBufferIdx === 0) {
          return;
        }
        var msg = slip.sliceByteArray(this.msgBuffer, 0, this.msgBufferIdx);
        if (this.onMessage) {
          this.onMessage(msg);
        }
        this.msgBufferIdx = 0;
        return msg;
      };
      return slip;
    });
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/osc/src/osc-transports.js
var require_osc_transports = __commonJS({
  "node_modules/osc/src/osc-transports.js"(exports, module) {
    var osc = osc || require_osc();
    var slip = slip || require_slip();
    var EventEmitter = EventEmitter || require_events().EventEmitter;
    (function() {
      "use strict";
      osc.supportsSerial = false;
      osc.firePacketEvents = function(port, packet, timeTag, packetInfo) {
        if (packet.address) {
          port.emit("message", packet, timeTag, packetInfo);
        } else {
          osc.fireBundleEvents(port, packet, timeTag, packetInfo);
        }
      };
      osc.fireBundleEvents = function(port, bundle, timeTag, packetInfo) {
        port.emit("bundle", bundle, timeTag, packetInfo);
        for (var i = 0; i < bundle.packets.length; i++) {
          var packet = bundle.packets[i];
          osc.firePacketEvents(port, packet, bundle.timeTag, packetInfo);
        }
      };
      osc.fireClosedPortSendError = function(port, msg) {
        msg = msg || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().";
        port.emit("error", msg);
      };
      osc.Port = function(options) {
        this.options = options || {};
        this.on("data", this.decodeOSC.bind(this));
      };
      var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
      p.constructor = osc.Port;
      p.send = function(oscPacket) {
        var args = Array.prototype.slice.call(arguments), encoded = this.encodeOSC(oscPacket), buf = osc.nativeBuffer(encoded);
        args[0] = buf;
        this.sendRaw.apply(this, args);
      };
      p.encodeOSC = function(packet) {
        packet = packet.buffer ? packet.buffer : packet;
        var encoded;
        try {
          encoded = osc.writePacket(packet, this.options);
        } catch (err) {
          this.emit("error", err);
        }
        return encoded;
      };
      p.decodeOSC = function(data, packetInfo) {
        data = osc.byteArray(data);
        this.emit("raw", data, packetInfo);
        try {
          var packet = osc.readPacket(data, this.options);
          this.emit("osc", packet, packetInfo);
          osc.firePacketEvents(this, packet, void 0, packetInfo);
        } catch (err) {
          this.emit("error", err);
        }
      };
      osc.SLIPPort = function(options) {
        var that = this;
        var o = this.options = options || {};
        o.useSLIP = o.useSLIP === void 0 ? true : o.useSLIP;
        this.decoder = new slip.Decoder({
          onMessage: this.decodeOSC.bind(this),
          onError: function(err) {
            that.emit("error", err);
          }
        });
        var decodeHandler = o.useSLIP ? this.decodeSLIPData : this.decodeOSC;
        this.on("data", decodeHandler.bind(this));
      };
      p = osc.SLIPPort.prototype = Object.create(osc.Port.prototype);
      p.constructor = osc.SLIPPort;
      p.encodeOSC = function(packet) {
        packet = packet.buffer ? packet.buffer : packet;
        var framed;
        try {
          var encoded = osc.writePacket(packet, this.options);
          framed = slip.encode(encoded);
        } catch (err) {
          this.emit("error", err);
        }
        return framed;
      };
      p.decodeSLIPData = function(data, packetInfo) {
        this.decoder.decode(data, packetInfo);
      };
      osc.relay = function(from, to, eventName, sendFnName, transformFn, sendArgs) {
        eventName = eventName || "message";
        sendFnName = sendFnName || "send";
        transformFn = transformFn || function() {
        };
        sendArgs = sendArgs ? [null].concat(sendArgs) : [];
        var listener = function(data) {
          sendArgs[0] = data;
          data = transformFn(data);
          to[sendFnName].apply(to, sendArgs);
        };
        from.on(eventName, listener);
        return {
          eventName,
          listener
        };
      };
      osc.relayPorts = function(from, to, o) {
        var eventName = o.raw ? "raw" : "osc", sendFnName = o.raw ? "sendRaw" : "send";
        return osc.relay(from, to, eventName, sendFnName, o.transform);
      };
      osc.stopRelaying = function(from, relaySpec) {
        from.removeListener(relaySpec.eventName, relaySpec.listener);
      };
      osc.Relay = function(port1, port2, options) {
        var o = this.options = options || {};
        o.raw = false;
        this.port1 = port1;
        this.port2 = port2;
        this.listen();
      };
      p = osc.Relay.prototype = Object.create(EventEmitter.prototype);
      p.constructor = osc.Relay;
      p.open = function() {
        this.port1.open();
        this.port2.open();
      };
      p.listen = function() {
        if (this.port1Spec && this.port2Spec) {
          this.close();
        }
        this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
        this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);
        var closeListener = this.close.bind(this);
        this.port1.on("close", closeListener);
        this.port2.on("close", closeListener);
      };
      p.close = function() {
        osc.stopRelaying(this.port1, this.port1Spec);
        osc.stopRelaying(this.port2, this.port2Spec);
        this.emit("close", this.port1, this.port2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = osc;
      }
    })();
  }
});

// node_modules/osc/src/platforms/osc-websocket-client.js
var require_osc_websocket_client = __commonJS({
  "node_modules/osc/src/platforms/osc-websocket-client.js"() {
    var osc = osc || require_osc();
    (function() {
      "use strict";
      osc.WebSocket = typeof WebSocket !== "undefined" ? WebSocket : require_browser();
      osc.WebSocketPort = function(options) {
        osc.Port.call(this, options);
        this.on("open", this.listen.bind(this));
        this.socket = options.socket;
        if (this.socket) {
          if (this.socket.readyState === 1) {
            osc.WebSocketPort.setupSocketForBinary(this.socket);
            this.emit("open", this.socket);
          } else {
            this.open();
          }
        }
      };
      var p = osc.WebSocketPort.prototype = Object.create(osc.Port.prototype);
      p.constructor = osc.WebSocketPort;
      p.open = function() {
        if (!this.socket || this.socket.readyState > 1) {
          this.socket = new osc.WebSocket(this.options.url);
        }
        osc.WebSocketPort.setupSocketForBinary(this.socket);
        var that = this;
        this.socket.onopen = function() {
          that.emit("open", that.socket);
        };
        this.socket.onerror = function(err) {
          that.emit("error", err);
        };
      };
      p.listen = function() {
        var that = this;
        this.socket.onmessage = function(e) {
          that.emit("data", e.data, e);
        };
        this.socket.onclose = function(e) {
          that.emit("close", e);
        };
        that.emit("ready");
      };
      p.sendRaw = function(encoded) {
        if (!this.socket || this.socket.readyState !== 1) {
          osc.fireClosedPortSendError(this);
          return;
        }
        this.socket.send(encoded);
      };
      p.close = function(code, reason) {
        this.socket.close(code, reason);
      };
      osc.WebSocketPort.setupSocketForBinary = function(socket) {
        socket.binaryType = osc.isNode ? "nodebuffer" : "arraybuffer";
      };
    })();
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@serialport/parser-byte-length/dist/index.js
var require_dist = __commonJS({
  "node_modules/@serialport/parser-byte-length/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteLengthParser = void 0;
    var stream_1 = require_stream();
    var ByteLengthParser = class extends stream_1.Transform {
      constructor(options) {
        super(options);
        if (typeof options.length !== "number") {
          throw new TypeError('"length" is not a number');
        }
        if (options.length < 1) {
          throw new TypeError('"length" is not greater than 0');
        }
        this.length = options.length;
        this.position = 0;
        this.buffer = Buffer.alloc(this.length);
      }
      _transform(chunk, _encoding, cb) {
        let cursor = 0;
        while (cursor < chunk.length) {
          this.buffer[this.position] = chunk[cursor];
          cursor++;
          this.position++;
          if (this.position === this.length) {
            this.push(this.buffer);
            this.buffer = Buffer.alloc(this.length);
            this.position = 0;
          }
        }
        cb();
      }
      _flush(cb) {
        this.push(this.buffer.slice(0, this.position));
        this.buffer = Buffer.alloc(this.length);
        cb();
      }
    };
    exports.ByteLengthParser = ByteLengthParser;
  }
});

// node_modules/@serialport/parser-cctalk/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@serialport/parser-cctalk/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CCTalkParser = void 0;
    var stream_1 = require_stream();
    var CCTalkParser = class extends stream_1.Transform {
      constructor(maxDelayBetweenBytesMs = 50) {
        super();
        this.array = [];
        this.cursor = 0;
        this.lastByteFetchTime = 0;
        this.maxDelayBetweenBytesMs = maxDelayBetweenBytesMs;
      }
      _transform(buffer, encoding, cb) {
        if (this.maxDelayBetweenBytesMs > 0) {
          const now = Date.now();
          if (now - this.lastByteFetchTime > this.maxDelayBetweenBytesMs) {
            this.array = [];
            this.cursor = 0;
          }
          this.lastByteFetchTime = now;
        }
        this.cursor += buffer.length;
        Array.from(buffer).map((byte) => this.array.push(byte));
        while (this.cursor > 1 && this.cursor >= this.array[1] + 5) {
          const FullMsgLength = this.array[1] + 5;
          const frame = Buffer.from(this.array.slice(0, FullMsgLength));
          this.array = this.array.slice(frame.length, this.array.length);
          this.cursor -= FullMsgLength;
          this.push(frame);
        }
        cb();
      }
    };
    exports.CCTalkParser = CCTalkParser;
  }
});

// node_modules/@serialport/parser-delimiter/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@serialport/parser-delimiter/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DelimiterParser = void 0;
    var stream_1 = require_stream();
    var DelimiterParser = class extends stream_1.Transform {
      constructor({ delimiter, includeDelimiter = false, ...options }) {
        super(options);
        if (delimiter === void 0) {
          throw new TypeError('"delimiter" is not a bufferable object');
        }
        if (delimiter.length === 0) {
          throw new TypeError('"delimiter" has a 0 or undefined length');
        }
        this.includeDelimiter = includeDelimiter;
        this.delimiter = Buffer.from(delimiter);
        this.buffer = Buffer.alloc(0);
      }
      _transform(chunk, encoding, cb) {
        let data = Buffer.concat([this.buffer, chunk]);
        let position;
        while ((position = data.indexOf(this.delimiter)) !== -1) {
          this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)));
          data = data.slice(position + this.delimiter.length);
        }
        this.buffer = data;
        cb();
      }
      _flush(cb) {
        this.push(this.buffer);
        this.buffer = Buffer.alloc(0);
        cb();
      }
    };
    exports.DelimiterParser = DelimiterParser;
  }
});

// node_modules/@serialport/parser-inter-byte-timeout/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@serialport/parser-inter-byte-timeout/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InterByteTimeoutParser = void 0;
    var stream_1 = require_stream();
    var InterByteTimeoutParser = class extends stream_1.Transform {
      constructor({ maxBufferSize = 65536, interval, ...transformOptions }) {
        super(transformOptions);
        if (!interval) {
          throw new TypeError('"interval" is required');
        }
        if (typeof interval !== "number" || Number.isNaN(interval)) {
          throw new TypeError('"interval" is not a number');
        }
        if (interval < 1) {
          throw new TypeError('"interval" is not greater than 0');
        }
        if (typeof maxBufferSize !== "number" || Number.isNaN(maxBufferSize)) {
          throw new TypeError('"maxBufferSize" is not a number');
        }
        if (maxBufferSize < 1) {
          throw new TypeError('"maxBufferSize" is not greater than 0');
        }
        this.maxBufferSize = maxBufferSize;
        this.currentPacket = [];
        this.interval = interval;
      }
      _transform(chunk, encoding, cb) {
        if (this.intervalID) {
          clearTimeout(this.intervalID);
        }
        for (let offset = 0; offset < chunk.length; offset++) {
          this.currentPacket.push(chunk[offset]);
          if (this.currentPacket.length >= this.maxBufferSize) {
            this.emitPacket();
          }
        }
        this.intervalID = setTimeout(this.emitPacket.bind(this), this.interval);
        cb();
      }
      emitPacket() {
        if (this.intervalID) {
          clearTimeout(this.intervalID);
        }
        if (this.currentPacket.length > 0) {
          this.push(Buffer.from(this.currentPacket));
        }
        this.currentPacket = [];
      }
      _flush(cb) {
        this.emitPacket();
        cb();
      }
    };
    exports.InterByteTimeoutParser = InterByteTimeoutParser;
  }
});

// node_modules/@serialport/parser-packet-length/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@serialport/parser-packet-length/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PacketLengthParser = void 0;
    var stream_1 = require_stream();
    var PacketLengthParser = class extends stream_1.Transform {
      constructor(options = {}) {
        super(options);
        const { delimiter = 170, packetOverhead = 2, lengthBytes = 1, lengthOffset = 1, maxLen = 255 } = options;
        this.opts = {
          delimiter,
          packetOverhead,
          lengthBytes,
          lengthOffset,
          maxLen
        };
        this.buffer = Buffer.alloc(0);
        this.start = false;
      }
      _transform(chunk, encoding, cb) {
        for (let ndx = 0; ndx < chunk.length; ndx++) {
          const byte = chunk[ndx];
          if (byte === this.opts.delimiter) {
            this.start = true;
          }
          if (true === this.start) {
            this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);
            if (this.buffer.length >= this.opts.lengthOffset + this.opts.lengthBytes) {
              const len = this.buffer.readUIntLE(this.opts.lengthOffset, this.opts.lengthBytes);
              if (this.buffer.length == len + this.opts.packetOverhead || len > this.opts.maxLen) {
                this.push(this.buffer);
                this.buffer = Buffer.alloc(0);
                this.start = false;
              }
            }
          }
        }
        cb();
      }
      _flush(cb) {
        this.push(this.buffer);
        this.buffer = Buffer.alloc(0);
        cb();
      }
    };
    exports.PacketLengthParser = PacketLengthParser;
  }
});

// node_modules/@serialport/parser-readline/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@serialport/parser-readline/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadlineParser = void 0;
    var parser_delimiter_1 = require_dist3();
    var ReadlineParser = class extends parser_delimiter_1.DelimiterParser {
      constructor(options) {
        const opts = {
          delimiter: Buffer.from("\n", "utf8"),
          encoding: "utf8",
          ...options
        };
        if (typeof opts.delimiter === "string") {
          opts.delimiter = Buffer.from(opts.delimiter, opts.encoding);
        }
        super(opts);
      }
    };
    exports.ReadlineParser = ReadlineParser;
  }
});

// node_modules/@serialport/parser-ready/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@serialport/parser-ready/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadyParser = void 0;
    var stream_1 = require_stream();
    var ReadyParser = class extends stream_1.Transform {
      constructor({ delimiter, ...options }) {
        if (delimiter === void 0) {
          throw new TypeError('"delimiter" is not a bufferable object');
        }
        if (delimiter.length === 0) {
          throw new TypeError('"delimiter" has a 0 or undefined length');
        }
        super(options);
        this.delimiter = Buffer.from(delimiter);
        this.readOffset = 0;
        this.ready = false;
      }
      _transform(chunk, encoding, cb) {
        if (this.ready) {
          this.push(chunk);
          return cb();
        }
        const delimiter = this.delimiter;
        let chunkOffset = 0;
        while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {
          if (delimiter[this.readOffset] === chunk[chunkOffset]) {
            this.readOffset++;
          } else {
            this.readOffset = 0;
          }
          chunkOffset++;
        }
        if (this.readOffset === delimiter.length) {
          this.ready = true;
          this.emit("ready");
          const chunkRest = chunk.slice(chunkOffset);
          if (chunkRest.length > 0) {
            this.push(chunkRest);
          }
        }
        cb();
      }
    };
    exports.ReadyParser = ReadyParser;
  }
});

// node_modules/@serialport/parser-regex/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@serialport/parser-regex/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RegexParser = void 0;
    var stream_1 = require_stream();
    var RegexParser = class extends stream_1.Transform {
      constructor({ regex, ...options }) {
        const opts = {
          encoding: "utf8",
          ...options
        };
        if (regex === void 0) {
          throw new TypeError('"options.regex" must be a regular expression pattern or object');
        }
        if (!(regex instanceof RegExp)) {
          regex = new RegExp(regex.toString());
        }
        super(opts);
        this.regex = regex;
        this.data = "";
      }
      _transform(chunk, encoding, cb) {
        const data = this.data + chunk;
        const parts = data.split(this.regex);
        this.data = parts.pop() || "";
        parts.forEach((part) => {
          this.push(part);
        });
        cb();
      }
      _flush(cb) {
        this.push(this.data);
        this.data = "";
        cb();
      }
    };
    exports.RegexParser = RegexParser;
  }
});

// node_modules/@serialport/parser-slip-encoder/dist/decoder.js
var require_decoder = __commonJS({
  "node_modules/@serialport/parser-slip-encoder/dist/decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SlipDecoder = void 0;
    var stream_1 = require_stream();
    var SlipDecoder = class extends stream_1.Transform {
      constructor(options = {}) {
        super(options);
        const { START, ESC = 219, END = 192, ESC_START, ESC_END = 220, ESC_ESC = 221 } = options;
        this.opts = {
          START,
          ESC,
          END,
          ESC_START,
          ESC_END,
          ESC_ESC
        };
        this.buffer = Buffer.alloc(0);
        this.escape = false;
        this.start = false;
      }
      _transform(chunk, encoding, cb) {
        for (let ndx = 0; ndx < chunk.length; ndx++) {
          let byte = chunk[ndx];
          if (byte === this.opts.START) {
            this.start = true;
            continue;
          } else if (void 0 == this.opts.START) {
            this.start = true;
          }
          if (this.escape) {
            if (byte === this.opts.ESC_START && this.opts.START) {
              byte = this.opts.START;
            } else if (byte === this.opts.ESC_ESC) {
              byte = this.opts.ESC;
            } else if (byte === this.opts.ESC_END) {
              byte = this.opts.END;
            } else {
              this.escape = false;
              this.push(this.buffer);
              this.buffer = Buffer.alloc(0);
            }
          } else {
            if (byte === this.opts.ESC) {
              this.escape = true;
              continue;
            }
            if (byte === this.opts.END) {
              this.push(this.buffer);
              this.buffer = Buffer.alloc(0);
              this.escape = false;
              this.start = false;
              continue;
            }
          }
          this.escape = false;
          if (this.start) {
            this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);
          }
        }
        cb();
      }
      _flush(cb) {
        this.push(this.buffer);
        this.buffer = Buffer.alloc(0);
        cb();
      }
    };
    exports.SlipDecoder = SlipDecoder;
  }
});

// node_modules/@serialport/parser-slip-encoder/dist/encoder.js
var require_encoder = __commonJS({
  "node_modules/@serialport/parser-slip-encoder/dist/encoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SlipEncoder = void 0;
    var stream_1 = require_stream();
    var SlipEncoder = class extends stream_1.Transform {
      constructor(options = {}) {
        super(options);
        const { START, ESC = 219, END = 192, ESC_START, ESC_END = 220, ESC_ESC = 221, bluetoothQuirk = false } = options;
        this.opts = {
          START,
          ESC,
          END,
          ESC_START,
          ESC_END,
          ESC_ESC,
          bluetoothQuirk
        };
      }
      _transform(chunk, encoding, cb) {
        const chunkLength = chunk.length;
        if (this.opts.bluetoothQuirk && chunkLength === 0) {
          return cb();
        }
        const encoded = Buffer.alloc(chunkLength * 2 + 2);
        let j = 0;
        if (this.opts.bluetoothQuirk == true) {
          encoded[j++] = this.opts.END;
        }
        if (this.opts.START !== void 0) {
          encoded[j++] = this.opts.START;
        }
        for (let i = 0; i < chunkLength; i++) {
          let byte = chunk[i];
          if (byte === this.opts.START && this.opts.ESC_START) {
            encoded[j++] = this.opts.ESC;
            byte = this.opts.ESC_START;
          } else if (byte === this.opts.END) {
            encoded[j++] = this.opts.ESC;
            byte = this.opts.ESC_END;
          } else if (byte === this.opts.ESC) {
            encoded[j++] = this.opts.ESC;
            byte = this.opts.ESC_ESC;
          }
          encoded[j++] = byte;
        }
        encoded[j++] = this.opts.END;
        cb(null, encoded.slice(0, j));
      }
    };
    exports.SlipEncoder = SlipEncoder;
  }
});

// node_modules/@serialport/parser-slip-encoder/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/@serialport/parser-slip-encoder/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_decoder(), exports);
    __exportStar(require_encoder(), exports);
  }
});

// node_modules/@serialport/parser-spacepacket/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@serialport/parser-spacepacket/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertHeaderBufferToObj = exports.HEADER_LENGTH = void 0;
    exports.HEADER_LENGTH = 6;
    var toOctetStr = (num) => {
      let str = Number(num).toString(2);
      while (str.length < 8) {
        str = `0${str}`;
      }
      return str;
    };
    var convertHeaderBufferToObj = (buf) => {
      const headerStr = Array.from(buf.slice(0, exports.HEADER_LENGTH)).reduce((accum, curr) => `${accum}${toOctetStr(curr)}`, "");
      const isVersion1 = headerStr.slice(0, 3) === "000";
      const versionNumber = isVersion1 ? 1 : "UNKNOWN_VERSION";
      const type = Number(headerStr[3]);
      const secondaryHeader = Number(headerStr[4]);
      const apid = parseInt(headerStr.slice(5, 16), 2);
      const sequenceFlags = parseInt(headerStr.slice(16, 18), 2);
      const packetName = parseInt(headerStr.slice(18, 32), 2);
      const dataLength = parseInt(headerStr.slice(-16), 2) + 1;
      return {
        versionNumber,
        identification: {
          apid,
          secondaryHeader,
          type
        },
        sequenceControl: {
          packetName,
          sequenceFlags
        },
        dataLength
      };
    };
    exports.convertHeaderBufferToObj = convertHeaderBufferToObj;
  }
});

// node_modules/@serialport/parser-spacepacket/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/@serialport/parser-spacepacket/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpacePacketParser = void 0;
    var stream_1 = require_stream();
    var utils_1 = require_utils();
    var SpacePacketParser = class extends stream_1.Transform {
      /**
       * A Transform stream that accepts a stream of octet data and emits object representations of
       * CCSDS Space Packets once a packet has been completely received.
       * @param {Object} [options] Configuration options for the stream
       * @param {Number} options.timeCodeFieldLength The length of the time code field within the data
       * @param {Number} options.ancillaryDataFieldLength The length of the ancillary data field within the data
       */
      constructor(options = {}) {
        super({ ...options, objectMode: true });
        this.timeCodeFieldLength = options.timeCodeFieldLength || 0;
        this.ancillaryDataFieldLength = options.ancillaryDataFieldLength || 0;
        this.dataSlice = this.timeCodeFieldLength + this.ancillaryDataFieldLength;
        this.dataBuffer = Buffer.alloc(0);
        this.headerBuffer = Buffer.alloc(0);
        this.dataLength = 0;
        this.expectingHeader = true;
      }
      /**
       * Bundle the header, secondary header if present, and the data into a JavaScript object to emit.
       * If more data has been received past the current packet, begin the process of parsing the next
       * packet(s).
       */
      pushCompletedPacket() {
        if (!this.header) {
          throw new Error("Missing header");
        }
        const timeCode = Buffer.from(this.dataBuffer.slice(0, this.timeCodeFieldLength));
        const ancillaryData = Buffer.from(this.dataBuffer.slice(this.timeCodeFieldLength, this.timeCodeFieldLength + this.ancillaryDataFieldLength));
        const data = Buffer.from(this.dataBuffer.slice(this.dataSlice, this.dataLength));
        const completedPacket = {
          header: { ...this.header },
          data: data.toString()
        };
        if (timeCode.length > 0 || ancillaryData.length > 0) {
          completedPacket.secondaryHeader = {};
          if (timeCode.length) {
            completedPacket.secondaryHeader.timeCode = timeCode.toString();
          }
          if (ancillaryData.length) {
            completedPacket.secondaryHeader.ancillaryData = ancillaryData.toString();
          }
        }
        this.push(completedPacket);
        const nextChunk = Buffer.from(this.dataBuffer.slice(this.dataLength));
        if (nextChunk.length >= utils_1.HEADER_LENGTH) {
          this.extractHeader(nextChunk);
        } else {
          this.headerBuffer = nextChunk;
          this.dataBuffer = Buffer.alloc(0);
          this.expectingHeader = true;
          this.dataLength = 0;
          this.header = void 0;
        }
      }
      /**
       * Build the Stream's headerBuffer property from the received Buffer chunk; extract data from it
       * if it's complete. If there's more to the chunk than just the header, initiate handling the
       * packet data.
       * @param chunk -  Build the Stream's headerBuffer property from
       */
      extractHeader(chunk) {
        const headerAsBuffer = Buffer.concat([this.headerBuffer, chunk]);
        const startOfDataBuffer = headerAsBuffer.slice(utils_1.HEADER_LENGTH);
        if (headerAsBuffer.length >= utils_1.HEADER_LENGTH) {
          this.header = (0, utils_1.convertHeaderBufferToObj)(headerAsBuffer);
          this.dataLength = this.header.dataLength;
          this.headerBuffer = Buffer.alloc(0);
          this.expectingHeader = false;
        } else {
          this.headerBuffer = headerAsBuffer;
        }
        if (startOfDataBuffer.length > 0) {
          this.dataBuffer = Buffer.from(startOfDataBuffer);
          if (this.dataBuffer.length >= this.dataLength) {
            this.pushCompletedPacket();
          }
        }
      }
      _transform(chunk, encoding, cb) {
        if (this.expectingHeader) {
          this.extractHeader(chunk);
        } else {
          this.dataBuffer = Buffer.concat([this.dataBuffer, chunk]);
          if (this.dataBuffer.length >= this.dataLength) {
            this.pushCompletedPacket();
          }
        }
        cb();
      }
      _flush(cb) {
        const remaining = Buffer.concat([this.headerBuffer, this.dataBuffer]);
        const remainingArray = Array.from(remaining);
        this.push(remainingArray);
        cb();
      }
    };
    exports.SpacePacketParser = SpacePacketParser;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@serialport/stream/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/@serialport/stream/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SerialPortStream = exports.DisconnectedError = void 0;
    var stream_1 = require_stream();
    var debug_1 = __importDefault(require_browser2());
    var debug = (0, debug_1.default)("serialport/stream");
    var DisconnectedError = class extends Error {
      constructor(message) {
        super(message);
        this.disconnected = true;
      }
    };
    exports.DisconnectedError = DisconnectedError;
    var defaultSetFlags = {
      brk: false,
      cts: false,
      dtr: true,
      rts: true
    };
    function allocNewReadPool(poolSize) {
      const pool = Buffer.allocUnsafe(poolSize);
      pool.used = 0;
      return pool;
    }
    var SerialPortStream = class extends stream_1.Duplex {
      /**
       * Create a new serial port object for the `path`. In the case of invalid arguments or invalid options, when constructing a new SerialPort it will throw an error. The port will open automatically by default, which is the equivalent of calling `port.open(openCallback)` in the next tick. You can disable this by setting the option `autoOpen` to `false`.
       * @emits open
       * @emits data
       * @emits close
       * @emits error
       */
      constructor(options, openCallback) {
        const settings = {
          autoOpen: true,
          endOnClose: false,
          highWaterMark: 64 * 1024,
          ...options
        };
        super({
          highWaterMark: settings.highWaterMark
        });
        if (!settings.binding) {
          throw new TypeError('"Bindings" is invalid pass it as `options.binding`');
        }
        if (!settings.path) {
          throw new TypeError(`"path" is not defined: ${settings.path}`);
        }
        if (typeof settings.baudRate !== "number") {
          throw new TypeError(`"baudRate" must be a number: ${settings.baudRate}`);
        }
        this.settings = settings;
        this.opening = false;
        this.closing = false;
        this._pool = allocNewReadPool(this.settings.highWaterMark);
        this._kMinPoolSpace = 128;
        if (this.settings.autoOpen) {
          this.open(openCallback);
        }
      }
      get path() {
        return this.settings.path;
      }
      get baudRate() {
        return this.settings.baudRate;
      }
      get isOpen() {
        var _a, _b;
        return ((_b = (_a = this.port) === null || _a === void 0 ? void 0 : _a.isOpen) !== null && _b !== void 0 ? _b : false) && !this.closing;
      }
      _error(error, callback) {
        if (callback) {
          callback.call(this, error);
        } else {
          this.emit("error", error);
        }
      }
      _asyncError(error, callback) {
        process.nextTick(() => this._error(error, callback));
      }
      /**
       * Opens a connection to the given serial port.
       * @param {ErrorCallback=} openCallback - Called after a connection is opened. If this is not provided and an error occurs, it will be emitted on the port's `error` event.
       * @emits open
       */
      open(openCallback) {
        if (this.isOpen) {
          return this._asyncError(new Error("Port is already open"), openCallback);
        }
        if (this.opening) {
          return this._asyncError(new Error("Port is opening"), openCallback);
        }
        const { highWaterMark, binding, autoOpen, endOnClose, ...openOptions } = this.settings;
        this.opening = true;
        debug("opening", `path: ${this.path}`);
        this.settings.binding.open(openOptions).then((port) => {
          debug("opened", `path: ${this.path}`);
          this.port = port;
          this.opening = false;
          this.emit("open");
          if (openCallback) {
            openCallback.call(this, null);
          }
        }, (err) => {
          this.opening = false;
          debug("Binding #open had an error", err);
          this._error(err, openCallback);
        });
      }
      /**
       * Changes the baud rate for an open port. Emits an error or calls the callback if the baud rate isn't supported.
       * @param {object=} options Only supports `baudRate`.
       * @param {number=} [options.baudRate] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate.
       * @param {ErrorCallback=} [callback] Called once the port's baud rate changes. If `.update` is called without a callback, and there is an error, an error event is emitted.
       * @returns {undefined}
       */
      update(options, callback) {
        if (!this.isOpen || !this.port) {
          debug("update attempted, but port is not open");
          return this._asyncError(new Error("Port is not open"), callback);
        }
        debug("update", `baudRate: ${options.baudRate}`);
        this.port.update(options).then(() => {
          debug("binding.update", "finished");
          this.settings.baudRate = options.baudRate;
          if (callback) {
            callback.call(this, null);
          }
        }, (err) => {
          debug("binding.update", "error", err);
          return this._error(err, callback);
        });
      }
      write(data, encoding, callback) {
        if (Array.isArray(data)) {
          data = Buffer.from(data);
        }
        if (typeof encoding === "function") {
          return super.write(data, encoding);
        }
        return super.write(data, encoding, callback);
      }
      _write(data, encoding, callback) {
        if (!this.isOpen || !this.port) {
          this.once("open", () => {
            this._write(data, encoding, callback);
          });
          return;
        }
        debug("_write", `${data.length} bytes of data`);
        this.port.write(data).then(() => {
          debug("binding.write", "write finished");
          callback(null);
        }, (err) => {
          debug("binding.write", "error", err);
          if (!err.canceled) {
            this._disconnected(err);
          }
          callback(err);
        });
      }
      _writev(data, callback) {
        debug("_writev", `${data.length} chunks of data`);
        const dataV = data.map((write) => write.chunk);
        this._write(Buffer.concat(dataV), void 0, callback);
      }
      _read(bytesToRead) {
        if (!this.isOpen || !this.port) {
          debug("_read", "queueing _read for after open");
          this.once("open", () => {
            this._read(bytesToRead);
          });
          return;
        }
        if (!this._pool || this._pool.length - this._pool.used < this._kMinPoolSpace) {
          debug("_read", "discarding the read buffer pool because it is below kMinPoolSpace");
          this._pool = allocNewReadPool(this.settings.highWaterMark);
        }
        const pool = this._pool;
        const toRead = Math.min(pool.length - pool.used, bytesToRead);
        const start = pool.used;
        debug("_read", `reading`, { start, toRead });
        this.port.read(pool, start, toRead).then(({ bytesRead }) => {
          debug("binding.read", `finished`, { bytesRead });
          if (bytesRead === 0) {
            debug("binding.read", "Zero bytes read closing readable stream");
            this.push(null);
            return;
          }
          pool.used += bytesRead;
          this.push(pool.slice(start, start + bytesRead));
        }, (err) => {
          debug("binding.read", `error`, err);
          if (!err.canceled) {
            this._disconnected(err);
          }
          this._read(bytesToRead);
        });
      }
      _disconnected(err) {
        if (!this.isOpen) {
          debug("disconnected aborted because already closed", err);
          return;
        }
        debug("disconnected", err);
        this.close(void 0, new DisconnectedError(err.message));
      }
      /**
       * Closes an open connection.
       *
       * If there are in progress writes when the port is closed the writes will error.
       * @param {ErrorCallback} callback Called once a connection is closed.
       * @param {Error} disconnectError used internally to propagate a disconnect error
       */
      close(callback, disconnectError = null) {
        if (!this.isOpen || !this.port) {
          debug("close attempted, but port is not open");
          return this._asyncError(new Error("Port is not open"), callback);
        }
        this.closing = true;
        debug("#close");
        this.port.close().then(() => {
          this.closing = false;
          debug("binding.close", "finished");
          this.emit("close", disconnectError);
          if (this.settings.endOnClose) {
            this.emit("end");
          }
          if (callback) {
            callback.call(this, disconnectError);
          }
        }, (err) => {
          this.closing = false;
          debug("binding.close", "had an error", err);
          return this._error(err, callback);
        });
      }
      /**
       * Set control flags on an open port. Uses [`SetCommMask`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363257(v=vs.85).aspx) for Windows and [`ioctl`](http://linux.die.net/man/4/tty_ioctl) for OS X and Linux.
       *
       * All options are operating system default when the port is opened. Every flag is set on each call to the provided or default values. If options isn't provided default options is used.
       */
      set(options, callback) {
        if (!this.isOpen || !this.port) {
          debug("set attempted, but port is not open");
          return this._asyncError(new Error("Port is not open"), callback);
        }
        const settings = { ...defaultSetFlags, ...options };
        debug("#set", settings);
        this.port.set(settings).then(() => {
          debug("binding.set", "finished");
          if (callback) {
            callback.call(this, null);
          }
        }, (err) => {
          debug("binding.set", "had an error", err);
          return this._error(err, callback);
        });
      }
      /**
       * Returns the control flags (CTS, DSR, DCD) on the open port.
       * Uses [`GetCommModemStatus`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363258(v=vs.85).aspx) for Windows and [`ioctl`](http://linux.die.net/man/4/tty_ioctl) for mac and linux.
       */
      get(callback) {
        if (!this.isOpen || !this.port) {
          debug("get attempted, but port is not open");
          return this._asyncError(new Error("Port is not open"), callback);
        }
        debug("#get");
        this.port.get().then((status) => {
          debug("binding.get", "finished");
          callback.call(this, null, status);
        }, (err) => {
          debug("binding.get", "had an error", err);
          return this._error(err, callback);
        });
      }
      /**
       * Flush discards data received but not read, and written but not transmitted by the operating system. For more technical details, see [`tcflush(fd, TCIOFLUSH)`](http://linux.die.net/man/3/tcflush) for Mac/Linux and [`FlushFileBuffers`](http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439) for Windows.
       */
      flush(callback) {
        if (!this.isOpen || !this.port) {
          debug("flush attempted, but port is not open");
          return this._asyncError(new Error("Port is not open"), callback);
        }
        debug("#flush");
        this.port.flush().then(() => {
          debug("binding.flush", "finished");
          if (callback) {
            callback.call(this, null);
          }
        }, (err) => {
          debug("binding.flush", "had an error", err);
          return this._error(err, callback);
        });
      }
      /**
         * Waits until all output data is transmitted to the serial port. After any pending write has completed it calls [`tcdrain()`](http://linux.die.net/man/3/tcdrain) or [FlushFileBuffers()](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364439(v=vs.85).aspx) to ensure it has been written to the device.
        * @example
        Write the `data` and wait until it has finished transmitting to the target serial port before calling the callback. This will queue until the port is open and writes are finished.
      
        ```js
        function writeAndDrain (data, callback) {
          port.write(data);
          port.drain(callback);
        }
        ```
        */
      drain(callback) {
        debug("drain");
        if (!this.isOpen || !this.port) {
          debug("drain queuing on port open");
          this.once("open", () => {
            this.drain(callback);
          });
          return;
        }
        this.port.drain().then(() => {
          debug("binding.drain", "finished");
          if (callback) {
            callback.call(this, null);
          }
        }, (err) => {
          debug("binding.drain", "had an error", err);
          return this._error(err, callback);
        });
      }
    };
    exports.SerialPortStream = SerialPortStream;
  }
});

// node_modules/@serialport/binding-mock/dist/index.js
var require_dist12 = __commonJS({
  "node_modules/@serialport/binding-mock/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var debugFactory = require_browser2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debugFactory__default = _interopDefaultLegacy(debugFactory);
    var debug = debugFactory__default["default"]("serialport/binding-mock");
    var ports = {};
    var serialNumber = 0;
    function resolveNextTick() {
      return new Promise((resolve) => process.nextTick(() => resolve()));
    }
    var CanceledError = class extends Error {
      constructor(message) {
        super(message);
        this.canceled = true;
      }
    };
    var MockBinding = {
      reset() {
        ports = {};
        serialNumber = 0;
      },
      // Create a mock port
      createPort(path, options = {}) {
        serialNumber++;
        const optWithDefaults = Object.assign({ echo: false, record: false, manufacturer: "The J5 Robotics Company", vendorId: void 0, productId: void 0, maxReadSize: 1024 }, options);
        ports[path] = {
          data: Buffer.alloc(0),
          echo: optWithDefaults.echo,
          record: optWithDefaults.record,
          readyData: optWithDefaults.readyData,
          maxReadSize: optWithDefaults.maxReadSize,
          info: {
            path,
            manufacturer: optWithDefaults.manufacturer,
            serialNumber: `${serialNumber}`,
            pnpId: void 0,
            locationId: void 0,
            vendorId: optWithDefaults.vendorId,
            productId: optWithDefaults.productId
          }
        };
        debug(serialNumber, "created port", JSON.stringify({ path, opt: options }));
      },
      async list() {
        debug(null, "list");
        return Object.values(ports).map((port) => port.info);
      },
      async open(options) {
        var _a;
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        if (!options.path) {
          throw new TypeError('"path" is not a valid port');
        }
        if (!options.baudRate) {
          throw new TypeError('"baudRate" is not a valid baudRate');
        }
        const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);
        const { path } = openOptions;
        debug(null, `open: opening path ${path}`);
        const port = ports[path];
        await resolveNextTick();
        if (!port) {
          throw new Error(`Port does not exist - please call MockBinding.createPort('${path}') first`);
        }
        const serialNumber2 = port.info.serialNumber;
        if ((_a = port.openOpt) === null || _a === void 0 ? void 0 : _a.lock) {
          debug(serialNumber2, "open: Port is locked cannot open");
          throw new Error("Port is locked cannot open");
        }
        debug(serialNumber2, `open: opened path ${path}`);
        port.openOpt = Object.assign({}, openOptions);
        return new MockPortBinding(port, openOptions);
      }
    };
    var MockPortBinding = class {
      constructor(port, openOptions) {
        this.port = port;
        this.openOptions = openOptions;
        this.pendingRead = null;
        this.isOpen = true;
        this.lastWrite = null;
        this.recording = Buffer.alloc(0);
        this.writeOperation = null;
        this.serialNumber = port.info.serialNumber;
        if (port.readyData) {
          const data = port.readyData;
          process.nextTick(() => {
            if (this.isOpen) {
              debug(this.serialNumber, "emitting ready data");
              this.emitData(data);
            }
          });
        }
      }
      // Emit data on a mock port
      emitData(data) {
        if (!this.isOpen || !this.port) {
          throw new Error("Port must be open to pretend to receive data");
        }
        const bufferData = Buffer.isBuffer(data) ? data : Buffer.from(data);
        debug(this.serialNumber, "emitting data - pending read:", Boolean(this.pendingRead));
        this.port.data = Buffer.concat([this.port.data, bufferData]);
        if (this.pendingRead) {
          process.nextTick(this.pendingRead);
          this.pendingRead = null;
        }
      }
      async close() {
        debug(this.serialNumber, "close");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        const port = this.port;
        if (!port) {
          throw new Error("already closed");
        }
        port.openOpt = void 0;
        port.data = Buffer.alloc(0);
        debug(this.serialNumber, "port is closed");
        this.serialNumber = void 0;
        this.isOpen = false;
        if (this.pendingRead) {
          this.pendingRead(new CanceledError("port is closed"));
        }
      }
      async read(buffer, offset, length) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        if (typeof offset !== "number" || isNaN(offset)) {
          throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
        }
        if (typeof length !== "number" || isNaN(length)) {
          throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
        }
        if (buffer.length < offset + length) {
          throw new Error("buffer is too small");
        }
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        debug(this.serialNumber, "read", length, "bytes");
        await resolveNextTick();
        if (!this.isOpen || !this.port) {
          throw new CanceledError("Read canceled");
        }
        if (this.port.data.length <= 0) {
          return new Promise((resolve, reject) => {
            this.pendingRead = (err) => {
              if (err) {
                return reject(err);
              }
              this.read(buffer, offset, length).then(resolve, reject);
            };
          });
        }
        const lengthToRead = this.port.maxReadSize > length ? length : this.port.maxReadSize;
        const data = this.port.data.slice(0, lengthToRead);
        const bytesRead = data.copy(buffer, offset);
        this.port.data = this.port.data.slice(lengthToRead);
        debug(this.serialNumber, "read", bytesRead, "bytes");
        return { bytesRead, buffer };
      }
      async write(buffer) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        if (!this.isOpen || !this.port) {
          debug("write", "error port is not open");
          throw new Error("Port is not open");
        }
        debug(this.serialNumber, "write", buffer.length, "bytes");
        if (this.writeOperation) {
          throw new Error("Overlapping writes are not supported and should be queued by the serialport object");
        }
        this.writeOperation = (async () => {
          await resolveNextTick();
          if (!this.isOpen || !this.port) {
            throw new Error("Write canceled");
          }
          const data = this.lastWrite = Buffer.from(buffer);
          if (this.port.record) {
            this.recording = Buffer.concat([this.recording, data]);
          }
          if (this.port.echo) {
            process.nextTick(() => {
              if (this.isOpen) {
                this.emitData(data);
              }
            });
          }
          this.writeOperation = null;
          debug(this.serialNumber, "writing finished");
        })();
        return this.writeOperation;
      }
      async update(options) {
        if (typeof options !== "object") {
          throw TypeError('"options" is not an object');
        }
        if (typeof options.baudRate !== "number") {
          throw new TypeError('"options.baudRate" is not a number');
        }
        debug(this.serialNumber, "update");
        if (!this.isOpen || !this.port) {
          throw new Error("Port is not open");
        }
        await resolveNextTick();
        if (this.port.openOpt) {
          this.port.openOpt.baudRate = options.baudRate;
        }
      }
      async set(options) {
        if (typeof options !== "object") {
          throw new TypeError('"options" is not an object');
        }
        debug(this.serialNumber, "set");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await resolveNextTick();
      }
      async get() {
        debug(this.serialNumber, "get");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await resolveNextTick();
        return {
          cts: true,
          dsr: false,
          dcd: false
        };
      }
      async getBaudRate() {
        var _a;
        debug(this.serialNumber, "getBaudRate");
        if (!this.isOpen || !this.port) {
          throw new Error("Port is not open");
        }
        await resolveNextTick();
        if (!((_a = this.port.openOpt) === null || _a === void 0 ? void 0 : _a.baudRate)) {
          throw new Error("Internal Error");
        }
        return {
          baudRate: this.port.openOpt.baudRate
        };
      }
      async flush() {
        debug(this.serialNumber, "flush");
        if (!this.isOpen || !this.port) {
          throw new Error("Port is not open");
        }
        await resolveNextTick();
        this.port.data = Buffer.alloc(0);
      }
      async drain() {
        debug(this.serialNumber, "drain");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await this.writeOperation;
        await resolveNextTick();
      }
    };
    exports.CanceledError = CanceledError;
    exports.MockBinding = MockBinding;
    exports.MockPortBinding = MockPortBinding;
  }
});

// node_modules/serialport/dist/serialport-mock.js
var require_serialport_mock = __commonJS({
  "node_modules/serialport/dist/serialport-mock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SerialPortMock = void 0;
    var stream_1 = require_dist11();
    var binding_mock_1 = require_dist12();
    var SerialPortMock = class extends stream_1.SerialPortStream {
      constructor(options, openCallback) {
        const opts = {
          binding: binding_mock_1.MockBinding,
          ...options
        };
        super(opts, openCallback);
      }
    };
    exports.SerialPortMock = SerialPortMock;
    SerialPortMock.list = binding_mock_1.MockBinding.list;
    SerialPortMock.binding = binding_mock_1.MockBinding;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS({
  "node_modules/node-gyp-build/node-gyp-build.js"(exports, module) {
    var fs = require_fs();
    var path = require_path();
    var os = require_os();
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
    var arch = process.env.npm_config_arch || os.arch();
    var platform = process.env.npm_config_platform || os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module.exports = load;
    function load(dir) {
      return runtimeRequire(load.resolve(dir));
    }
    load.resolve = load.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"])
          dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug)
          return debug;
      }
      var prebuild = resolve(dir);
      if (prebuild)
        return prebuild;
      var nearby = resolve(path.dirname(process.execPath));
      if (nearby)
        return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
        // eslint-disable-line
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple)
          return;
        var prebuilds = path.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner)
          return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2)
        return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2)
        return;
      if (!architectures.length)
        return;
      if (!architectures.every(Boolean))
        return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null)
          return false;
        if (tuple.platform !== platform2)
          return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node")
        return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null)
          return false;
        if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
          return false;
        if (tags.abi !== abi2 && !tags.napi)
          return false;
        if (tags.uv && tags.uv !== uv)
          return false;
        if (tags.armv && tags.armv !== armv)
          return false;
        if (tags.libc && tags.libc !== libc)
          return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isNwjs() {
      return !!(process.versions && process.versions.nw);
    }
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS({
  "node_modules/node-gyp-build/index.js"(exports, module) {
    if (typeof process.addon === "function") {
      module.exports = process.addon.bind(process);
    } else {
      module.exports = require_node_gyp_build();
    }
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@serialport/bindings-cpp/dist/load-bindings.js
var require_load_bindings = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/load-bindings.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asyncWrite = exports.asyncRead = exports.asyncUpdate = exports.asyncSet = exports.asyncOpen = exports.asyncList = exports.asyncGetBaudRate = exports.asyncGet = exports.asyncFlush = exports.asyncDrain = exports.asyncClose = void 0;
    var node_gyp_build_1 = __importDefault(require_node_gyp_build2());
    var util_1 = require_util();
    var path_1 = require_path();
    var binding = (0, node_gyp_build_1.default)((0, path_1.join)(__dirname, "../"));
    exports.asyncClose = binding.close ? (0, util_1.promisify)(binding.close) : async () => {
      throw new Error('"binding.close" Method not implemented');
    };
    exports.asyncDrain = binding.drain ? (0, util_1.promisify)(binding.drain) : async () => {
      throw new Error('"binding.drain" Method not implemented');
    };
    exports.asyncFlush = binding.flush ? (0, util_1.promisify)(binding.flush) : async () => {
      throw new Error('"binding.flush" Method not implemented');
    };
    exports.asyncGet = binding.get ? (0, util_1.promisify)(binding.get) : async () => {
      throw new Error('"binding.get" Method not implemented');
    };
    exports.asyncGetBaudRate = binding.getBaudRate ? (0, util_1.promisify)(binding.getBaudRate) : async () => {
      throw new Error('"binding.getBaudRate" Method not implemented');
    };
    exports.asyncList = binding.list ? (0, util_1.promisify)(binding.list) : async () => {
      throw new Error('"binding.list" Method not implemented');
    };
    exports.asyncOpen = binding.open ? (0, util_1.promisify)(binding.open) : async () => {
      throw new Error('"binding.open" Method not implemented');
    };
    exports.asyncSet = binding.set ? (0, util_1.promisify)(binding.set) : async () => {
      throw new Error('"binding.set" Method not implemented');
    };
    exports.asyncUpdate = binding.update ? (0, util_1.promisify)(binding.update) : async () => {
      throw new Error('"binding.update" Method not implemented');
    };
    exports.asyncRead = binding.read ? (0, util_1.promisify)(binding.read) : async () => {
      throw new Error('"binding.read" Method not implemented');
    };
    exports.asyncWrite = binding.read ? (0, util_1.promisify)(binding.write) : async () => {
      throw new Error('"binding.write" Method not implemented');
    };
  }
});

// node_modules/@serialport/bindings-cpp/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingsError = void 0;
    var BindingsError = class extends Error {
      constructor(message, { canceled = false } = {}) {
        super(message);
        this.canceled = canceled;
      }
    };
    exports.BindingsError = BindingsError;
  }
});

// node_modules/@serialport/bindings-cpp/dist/poller.js
var require_poller = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/poller.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Poller = exports.EVENTS = void 0;
    var debug_1 = __importDefault(require_browser2());
    var events_1 = require_events();
    var path_1 = require_path();
    var node_gyp_build_1 = __importDefault(require_node_gyp_build2());
    var errors_1 = require_errors();
    var { Poller: PollerBindings } = (0, node_gyp_build_1.default)((0, path_1.join)(__dirname, "../"));
    var logger = (0, debug_1.default)("serialport/bindings-cpp/poller");
    exports.EVENTS = {
      UV_READABLE: 1,
      UV_WRITABLE: 2,
      UV_DISCONNECT: 4
    };
    function handleEvent(error, eventFlag) {
      if (error) {
        logger("error", error);
        this.emit("readable", error);
        this.emit("writable", error);
        this.emit("disconnect", error);
        return;
      }
      if (eventFlag & exports.EVENTS.UV_READABLE) {
        logger('received "readable"');
        this.emit("readable", null);
      }
      if (eventFlag & exports.EVENTS.UV_WRITABLE) {
        logger('received "writable"');
        this.emit("writable", null);
      }
      if (eventFlag & exports.EVENTS.UV_DISCONNECT) {
        logger('received "disconnect"');
        this.emit("disconnect", null);
      }
    }
    var Poller = class extends events_1.EventEmitter {
      constructor(fd, FDPoller = PollerBindings) {
        logger("Creating poller");
        super();
        this.poller = new FDPoller(fd, handleEvent.bind(this));
      }
      /**
       * Wait for the next event to occur
       * @param {string} event ('readable'|'writable'|'disconnect')
       * @returns {Poller} returns itself
       */
      once(event, callback) {
        switch (event) {
          case "readable":
            this.poll(exports.EVENTS.UV_READABLE);
            break;
          case "writable":
            this.poll(exports.EVENTS.UV_WRITABLE);
            break;
          case "disconnect":
            this.poll(exports.EVENTS.UV_DISCONNECT);
            break;
        }
        return super.once(event, callback);
      }
      /**
       * Ask the bindings to listen for an event, it is recommend to use `.once()` for easy use
       * @param {EVENTS} eventFlag polls for an event or group of events based upon a flag.
       */
      poll(eventFlag = 0) {
        if (eventFlag & exports.EVENTS.UV_READABLE) {
          logger('Polling for "readable"');
        }
        if (eventFlag & exports.EVENTS.UV_WRITABLE) {
          logger('Polling for "writable"');
        }
        if (eventFlag & exports.EVENTS.UV_DISCONNECT) {
          logger('Polling for "disconnect"');
        }
        this.poller.poll(eventFlag);
      }
      /**
       * Stop listening for events and cancel all outstanding listening with an error
       */
      stop() {
        logger("Stopping poller");
        this.poller.stop();
        this.emitCanceled();
      }
      destroy() {
        logger("Destroying poller");
        this.poller.destroy();
        this.emitCanceled();
      }
      emitCanceled() {
        const err = new errors_1.BindingsError("Canceled", { canceled: true });
        this.emit("readable", err);
        this.emit("writable", err);
        this.emit("disconnect", err);
      }
    };
    exports.Poller = Poller;
  }
});

// node_modules/@serialport/bindings-cpp/dist/unix-read.js
var require_unix_read = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/unix-read.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unixRead = void 0;
    var util_1 = require_util();
    var fs_1 = require_fs();
    var errors_1 = require_errors();
    var debug_1 = __importDefault(require_browser2());
    var logger = (0, debug_1.default)("serialport/bindings-cpp/unixRead");
    var readAsync = (0, util_1.promisify)(fs_1.read);
    var readable = (binding) => {
      return new Promise((resolve, reject) => {
        if (!binding.poller) {
          throw new Error("No poller on bindings");
        }
        binding.poller.once("readable", (err) => err ? reject(err) : resolve());
      });
    };
    var unixRead = async ({ binding, buffer, offset, length, fsReadAsync = readAsync }) => {
      logger("Starting read");
      if (!binding.isOpen || !binding.fd) {
        throw new errors_1.BindingsError("Port is not open", { canceled: true });
      }
      try {
        const { bytesRead } = await fsReadAsync(binding.fd, buffer, offset, length, null);
        if (bytesRead === 0) {
          return (0, exports.unixRead)({ binding, buffer, offset, length, fsReadAsync });
        }
        logger("Finished read", bytesRead, "bytes");
        return { bytesRead, buffer };
      } catch (err) {
        logger("read error", err);
        if (err.code === "EAGAIN" || err.code === "EWOULDBLOCK" || err.code === "EINTR") {
          if (!binding.isOpen) {
            throw new errors_1.BindingsError("Port is not open", { canceled: true });
          }
          logger("waiting for readable because of code:", err.code);
          await readable(binding);
          return (0, exports.unixRead)({ binding, buffer, offset, length, fsReadAsync });
        }
        const disconnectError = err.code === "EBADF" || // Bad file number means we got closed
        err.code === "ENXIO" || // No such device or address probably usb disconnect
        err.code === "UNKNOWN" || err.errno === -1;
        if (disconnectError) {
          err.disconnect = true;
          logger("disconnecting", err);
        }
        throw err;
      }
    };
    exports.unixRead = unixRead;
  }
});

// node_modules/@serialport/bindings-cpp/dist/unix-write.js
var require_unix_write = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/unix-write.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unixWrite = void 0;
    var fs_1 = require_fs();
    var debug_1 = __importDefault(require_browser2());
    var util_1 = require_util();
    var logger = (0, debug_1.default)("serialport/bindings-cpp/unixWrite");
    var writeAsync = (0, util_1.promisify)(fs_1.write);
    var writable = (binding) => {
      return new Promise((resolve, reject) => {
        binding.poller.once("writable", (err) => err ? reject(err) : resolve());
      });
    };
    var unixWrite = async ({ binding, buffer, offset = 0, fsWriteAsync = writeAsync }) => {
      const bytesToWrite = buffer.length - offset;
      logger("Starting write", buffer.length, "bytes offset", offset, "bytesToWrite", bytesToWrite);
      if (!binding.isOpen || !binding.fd) {
        throw new Error("Port is not open");
      }
      try {
        const { bytesWritten } = await fsWriteAsync(binding.fd, buffer, offset, bytesToWrite);
        logger("write returned: wrote", bytesWritten, "bytes");
        if (bytesWritten + offset < buffer.length) {
          if (!binding.isOpen) {
            throw new Error("Port is not open");
          }
          return (0, exports.unixWrite)({ binding, buffer, offset: bytesWritten + offset, fsWriteAsync });
        }
        logger("Finished writing", bytesWritten + offset, "bytes");
      } catch (err) {
        logger("write errored", err);
        if (err.code === "EAGAIN" || err.code === "EWOULDBLOCK" || err.code === "EINTR") {
          if (!binding.isOpen) {
            throw new Error("Port is not open");
          }
          logger("waiting for writable because of code:", err.code);
          await writable(binding);
          return (0, exports.unixWrite)({ binding, buffer, offset, fsWriteAsync });
        }
        const disconnectError = err.code === "EBADF" || // Bad file number means we got closed
        err.code === "ENXIO" || // No such device or address probably usb disconnect
        err.code === "UNKNOWN" || err.errno === -1;
        if (disconnectError) {
          err.disconnect = true;
          logger("disconnecting", err);
        }
        logger("error", err);
        throw err;
      }
    };
    exports.unixWrite = unixWrite;
  }
});

// node_modules/@serialport/bindings-cpp/dist/darwin.js
var require_darwin = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/darwin.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DarwinPortBinding = exports.DarwinBinding = void 0;
    var debug_1 = __importDefault(require_browser2());
    var load_bindings_1 = require_load_bindings();
    var poller_1 = require_poller();
    var unix_read_1 = require_unix_read();
    var unix_write_1 = require_unix_write();
    var debug = (0, debug_1.default)("serialport/bindings-cpp");
    exports.DarwinBinding = {
      list() {
        debug("list");
        return (0, load_bindings_1.asyncList)();
      },
      async open(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        if (!options.path) {
          throw new TypeError('"path" is not a valid port');
        }
        if (!options.baudRate) {
          throw new TypeError('"baudRate" is not a valid baudRate');
        }
        debug("open");
        const openOptions = Object.assign({ vmin: 1, vtime: 0, dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);
        const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);
        return new DarwinPortBinding(fd, openOptions);
      }
    };
    var DarwinPortBinding = class {
      constructor(fd, options) {
        this.fd = fd;
        this.openOptions = options;
        this.poller = new poller_1.Poller(fd);
        this.writeOperation = null;
      }
      get isOpen() {
        return this.fd !== null;
      }
      async close() {
        debug("close");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        const fd = this.fd;
        this.poller.stop();
        this.poller.destroy();
        this.fd = null;
        await (0, load_bindings_1.asyncClose)(fd);
      }
      async read(buffer, offset, length) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        if (typeof offset !== "number" || isNaN(offset)) {
          throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
        }
        if (typeof length !== "number" || isNaN(length)) {
          throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
        }
        debug("read");
        if (buffer.length < offset + length) {
          throw new Error("buffer is too small");
        }
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, unix_read_1.unixRead)({ binding: this, buffer, offset, length });
      }
      async write(buffer) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        debug("write", buffer.length, "bytes");
        if (!this.isOpen) {
          debug("write", "error port is not open");
          throw new Error("Port is not open");
        }
        this.writeOperation = (async () => {
          if (buffer.length === 0) {
            return;
          }
          await (0, unix_write_1.unixWrite)({ binding: this, buffer });
          this.writeOperation = null;
        })();
        return this.writeOperation;
      }
      async update(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw TypeError('"options" is not an object');
        }
        if (typeof options.baudRate !== "number") {
          throw new TypeError('"options.baudRate" is not a number');
        }
        debug("update");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncUpdate)(this.fd, options);
      }
      async set(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        debug("set", options);
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncSet)(this.fd, options);
      }
      async get() {
        debug("get");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, load_bindings_1.asyncGet)(this.fd);
      }
      async getBaudRate() {
        debug("getBaudRate");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        throw new Error("getBaudRate is not implemented on darwin");
      }
      async flush() {
        debug("flush");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncFlush)(this.fd);
      }
      async drain() {
        debug("drain");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await this.writeOperation;
        await (0, load_bindings_1.asyncDrain)(this.fd);
      }
    };
    exports.DarwinPortBinding = DarwinPortBinding;
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@serialport/bindings-cpp/dist/linux-list.js
var require_linux_list = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/linux-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.linuxList = void 0;
    var child_process_1 = require_child_process();
    var parser_readline_1 = require_dist6();
    function checkPathOfDevice(path) {
      return /(tty(S|WCH|ACM|USB|AMA|MFD|O|XRUSB)|rfcomm)/.test(path) && path;
    }
    function propName(name) {
      return {
        DEVNAME: "path",
        ID_VENDOR_ENC: "manufacturer",
        ID_SERIAL_SHORT: "serialNumber",
        ID_VENDOR_ID: "vendorId",
        ID_MODEL_ID: "productId",
        DEVLINKS: "pnpId"
      }[name.toUpperCase()];
    }
    function decodeHexEscape(str) {
      return str.replace(/\\x([a-fA-F0-9]{2})/g, (a, b) => {
        return String.fromCharCode(parseInt(b, 16));
      });
    }
    function propVal(name, val) {
      if (name === "pnpId") {
        const match = val.match(/\/by-id\/([^\s]+)/);
        return (match === null || match === void 0 ? void 0 : match[1]) || void 0;
      }
      if (name === "manufacturer") {
        return decodeHexEscape(val);
      }
      if (/^0x/.test(val)) {
        return val.substr(2);
      }
      return val;
    }
    function linuxList(spawnCmd = child_process_1.spawn) {
      const ports = [];
      const udevadm = spawnCmd("udevadm", ["info", "-e"]);
      const lines = udevadm.stdout.pipe(new parser_readline_1.ReadlineParser());
      let skipPort = false;
      let port = {
        path: "",
        manufacturer: void 0,
        serialNumber: void 0,
        pnpId: void 0,
        locationId: void 0,
        vendorId: void 0,
        productId: void 0
      };
      lines.on("data", (line) => {
        const lineType = line.slice(0, 1);
        const data = line.slice(3);
        if (lineType === "P") {
          port = {
            path: "",
            manufacturer: void 0,
            serialNumber: void 0,
            pnpId: void 0,
            locationId: void 0,
            vendorId: void 0,
            productId: void 0
          };
          skipPort = false;
          return;
        }
        if (skipPort) {
          return;
        }
        if (lineType === "N") {
          if (checkPathOfDevice(data)) {
            ports.push(port);
          } else {
            skipPort = true;
          }
          return;
        }
        if (lineType === "E") {
          const keyValue = data.match(/^(.+)=(.*)/);
          if (!keyValue) {
            return;
          }
          const key = propName(keyValue[1]);
          if (!key) {
            return;
          }
          port[key] = propVal(key, keyValue[2]);
        }
      });
      return new Promise((resolve, reject) => {
        udevadm.on("close", (code) => {
          if (code) {
            reject(new Error(`Error listing ports udevadm exited with error code: ${code}`));
          }
        });
        udevadm.on("error", reject);
        lines.on("error", reject);
        lines.on("finish", () => resolve(ports));
      });
    }
    exports.linuxList = linuxList;
  }
});

// node_modules/@serialport/bindings-cpp/dist/linux.js
var require_linux = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/linux.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinuxPortBinding = exports.LinuxBinding = void 0;
    var debug_1 = __importDefault(require_browser2());
    var linux_list_1 = require_linux_list();
    var poller_1 = require_poller();
    var unix_read_1 = require_unix_read();
    var unix_write_1 = require_unix_write();
    var load_bindings_1 = require_load_bindings();
    var debug = (0, debug_1.default)("serialport/bindings-cpp");
    exports.LinuxBinding = {
      list() {
        debug("list");
        return (0, linux_list_1.linuxList)();
      },
      async open(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        if (!options.path) {
          throw new TypeError('"path" is not a valid port');
        }
        if (!options.baudRate) {
          throw new TypeError('"baudRate" is not a valid baudRate');
        }
        debug("open");
        const openOptions = Object.assign({ vmin: 1, vtime: 0, dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);
        const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);
        this.fd = fd;
        return new LinuxPortBinding(fd, openOptions);
      }
    };
    var LinuxPortBinding = class {
      constructor(fd, openOptions) {
        this.fd = fd;
        this.openOptions = openOptions;
        this.poller = new poller_1.Poller(fd);
        this.writeOperation = null;
      }
      get isOpen() {
        return this.fd !== null;
      }
      async close() {
        debug("close");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        const fd = this.fd;
        this.poller.stop();
        this.poller.destroy();
        this.fd = null;
        await (0, load_bindings_1.asyncClose)(fd);
      }
      async read(buffer, offset, length) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        if (typeof offset !== "number" || isNaN(offset)) {
          throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
        }
        if (typeof length !== "number" || isNaN(length)) {
          throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
        }
        debug("read");
        if (buffer.length < offset + length) {
          throw new Error("buffer is too small");
        }
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, unix_read_1.unixRead)({ binding: this, buffer, offset, length });
      }
      async write(buffer) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        debug("write", buffer.length, "bytes");
        if (!this.isOpen) {
          debug("write", "error port is not open");
          throw new Error("Port is not open");
        }
        this.writeOperation = (async () => {
          if (buffer.length === 0) {
            return;
          }
          await (0, unix_write_1.unixWrite)({ binding: this, buffer });
          this.writeOperation = null;
        })();
        return this.writeOperation;
      }
      async update(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw TypeError('"options" is not an object');
        }
        if (typeof options.baudRate !== "number") {
          throw new TypeError('"options.baudRate" is not a number');
        }
        debug("update");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncUpdate)(this.fd, options);
      }
      async set(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        debug("set");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncSet)(this.fd, options);
      }
      async get() {
        debug("get");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, load_bindings_1.asyncGet)(this.fd);
      }
      async getBaudRate() {
        debug("getBaudRate");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, load_bindings_1.asyncGetBaudRate)(this.fd);
      }
      async flush() {
        debug("flush");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncFlush)(this.fd);
      }
      async drain() {
        debug("drain");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await this.writeOperation;
        await (0, load_bindings_1.asyncDrain)(this.fd);
      }
    };
    exports.LinuxPortBinding = LinuxPortBinding;
  }
});

// node_modules/@serialport/bindings-cpp/dist/win32-sn-parser.js
var require_win32_sn_parser = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/win32-sn-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialNumParser = void 0;
    var PARSERS = [/USB\\(?:.+)\\(.+)/, /FTDIBUS\\(?:.+)\+(.+?)A?\\.+/];
    var serialNumParser = (pnpId) => {
      if (!pnpId) {
        return null;
      }
      for (const parser of PARSERS) {
        const sn = pnpId.match(parser);
        if (sn) {
          return sn[1];
        }
      }
      return null;
    };
    exports.serialNumParser = serialNumParser;
  }
});

// node_modules/@serialport/bindings-cpp/dist/win32.js
var require_win32 = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/win32.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WindowsPortBinding = exports.WindowsBinding = void 0;
    var debug_1 = __importDefault(require_browser2());
    var _1 = require_dist14();
    var load_bindings_1 = require_load_bindings();
    var win32_sn_parser_1 = require_win32_sn_parser();
    var debug = (0, debug_1.default)("serialport/bindings-cpp");
    exports.WindowsBinding = {
      async list() {
        const ports = await (0, load_bindings_1.asyncList)();
        return ports.map((port) => {
          if (port.pnpId && !port.serialNumber) {
            const serialNumber = (0, win32_sn_parser_1.serialNumParser)(port.pnpId);
            if (serialNumber) {
              return Object.assign(Object.assign({}, port), { serialNumber });
            }
          }
          return port;
        });
      },
      async open(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        if (!options.path) {
          throw new TypeError('"path" is not a valid port');
        }
        if (!options.baudRate) {
          throw new TypeError('"baudRate" is not a valid baudRate');
        }
        debug("open");
        const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, rtsMode: "handshake", xon: false, xoff: false, xany: false, hupcl: true }, options);
        const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);
        return new WindowsPortBinding(fd, openOptions);
      }
    };
    var WindowsPortBinding = class {
      constructor(fd, options) {
        this.fd = fd;
        this.openOptions = options;
        this.writeOperation = null;
      }
      get isOpen() {
        return this.fd !== null;
      }
      async close() {
        debug("close");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        const fd = this.fd;
        this.fd = null;
        await (0, load_bindings_1.asyncClose)(fd);
      }
      async read(buffer, offset, length) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        if (typeof offset !== "number" || isNaN(offset)) {
          throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
        }
        if (typeof length !== "number" || isNaN(length)) {
          throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
        }
        debug("read");
        if (buffer.length < offset + length) {
          throw new Error("buffer is too small");
        }
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        try {
          const bytesRead = await (0, load_bindings_1.asyncRead)(this.fd, buffer, offset, length);
          return { bytesRead, buffer };
        } catch (err) {
          if (!this.isOpen) {
            throw new _1.BindingsError(err.message, { canceled: true });
          }
          throw err;
        }
      }
      async write(buffer) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        debug("write", buffer.length, "bytes");
        if (!this.isOpen) {
          debug("write", "error port is not open");
          throw new Error("Port is not open");
        }
        this.writeOperation = (async () => {
          if (buffer.length === 0) {
            return;
          }
          await (0, load_bindings_1.asyncWrite)(this.fd, buffer);
          this.writeOperation = null;
        })();
        return this.writeOperation;
      }
      async update(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw TypeError('"options" is not an object');
        }
        if (typeof options.baudRate !== "number") {
          throw new TypeError('"options.baudRate" is not a number');
        }
        debug("update");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncUpdate)(this.fd, options);
      }
      async set(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        debug("set", options);
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncSet)(this.fd, options);
      }
      async get() {
        debug("get");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, load_bindings_1.asyncGet)(this.fd);
      }
      async getBaudRate() {
        debug("getBaudRate");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, load_bindings_1.asyncGetBaudRate)(this.fd);
      }
      async flush() {
        debug("flush");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncFlush)(this.fd);
      }
      async drain() {
        debug("drain");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await this.writeOperation;
        await (0, load_bindings_1.asyncDrain)(this.fd);
      }
    };
    exports.WindowsPortBinding = WindowsPortBinding;
  }
});

// node_modules/@serialport/bindings-interface/dist/index.js
var require_dist13 = __commonJS({
  "node_modules/@serialport/bindings-interface/dist/index.js"() {
    "use strict";
  }
});

// node_modules/@serialport/bindings-cpp/dist/index.js
var require_dist14 = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.autoDetect = void 0;
    var debug_1 = __importDefault(require_browser2());
    var darwin_1 = require_darwin();
    var linux_1 = require_linux();
    var win32_1 = require_win32();
    var debug = (0, debug_1.default)("serialport/bindings-cpp");
    __exportStar(require_dist13(), exports);
    __exportStar(require_darwin(), exports);
    __exportStar(require_linux(), exports);
    __exportStar(require_win32(), exports);
    __exportStar(require_errors(), exports);
    function autoDetect() {
      switch (process.platform) {
        case "win32":
          debug("loading WindowsBinding");
          return win32_1.WindowsBinding;
        case "darwin":
          debug("loading DarwinBinding");
          return darwin_1.DarwinBinding;
        default:
          debug("loading LinuxBinding");
          return linux_1.LinuxBinding;
      }
    }
    exports.autoDetect = autoDetect;
  }
});

// node_modules/serialport/dist/serialport.js
var require_serialport = __commonJS({
  "node_modules/serialport/dist/serialport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SerialPort = void 0;
    var stream_1 = require_dist11();
    var bindings_cpp_1 = require_dist14();
    var DetectedBinding = (0, bindings_cpp_1.autoDetect)();
    var SerialPort = class extends stream_1.SerialPortStream {
      constructor(options, openCallback) {
        const opts = {
          binding: DetectedBinding,
          ...options
        };
        super(opts, openCallback);
      }
    };
    exports.SerialPort = SerialPort;
    SerialPort.list = DetectedBinding.list;
    SerialPort.binding = DetectedBinding;
  }
});

// node_modules/serialport/dist/index.js
var require_dist15 = __commonJS({
  "node_modules/serialport/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_dist(), exports);
    __exportStar(require_dist2(), exports);
    __exportStar(require_dist3(), exports);
    __exportStar(require_dist4(), exports);
    __exportStar(require_dist5(), exports);
    __exportStar(require_dist6(), exports);
    __exportStar(require_dist7(), exports);
    __exportStar(require_dist8(), exports);
    __exportStar(require_dist9(), exports);
    __exportStar(require_dist10(), exports);
    __exportStar(require_serialport_mock(), exports);
    __exportStar(require_serialport(), exports);
  }
});

// node_modules/osc/src/platforms/osc-node-serialport.js
var require_osc_node_serialport = __commonJS({
  "node_modules/osc/src/platforms/osc-node-serialport.js"() {
    var osc = osc || require_osc();
    var SerialPort = require_dist15().SerialPort;
    osc.supportsSerial = true;
    osc.SerialPort = function(options) {
      this.on("open", this.listen.bind(this));
      osc.SLIPPort.call(this, options);
      this.options.bitrate = this.options.bitrate || 9600;
      this.serialPort = options.serialPort;
      if (this.serialPort) {
        this.emit("open", this.serialPort);
      }
    };
    var p = osc.SerialPort.prototype = Object.create(osc.SLIPPort.prototype);
    p.constructor = osc.SerialPort;
    p.open = function() {
      if (this.serialPort) {
        this.once("close", this.open.bind(this));
        this.close();
        return;
      }
      var that = this;
      this.serialPort = new SerialPort({
        path: this.options.devicePath,
        baudRate: this.options.bitrate,
        autoOpen: false
      });
      this.serialPort.on("error", function(err) {
        that.emit("error", err);
      });
      this.serialPort.on("open", function() {
        that.emit("open", that.serialPort);
      });
      this.serialPort.open();
    };
    p.listen = function() {
      var that = this;
      this.serialPort.on("data", function(data) {
        that.emit("data", data, void 0);
      });
      this.serialPort.on("close", function() {
        that.emit("close");
      });
      that.emit("ready");
    };
    p.sendRaw = function(encoded) {
      if (!this.serialPort || !this.serialPort.isOpen) {
        osc.fireClosedPortSendError(this);
        return;
      }
      var that = this;
      this.serialPort.write(encoded);
    };
    p.close = function() {
      if (this.serialPort) {
        this.serialPort.close();
      }
    };
  }
});

// node_modules/osc/src/platforms/osc-node-serialport-loader.js
var require_osc_node_serialport_loader = __commonJS({
  "node_modules/osc/src/platforms/osc-node-serialport-loader.js"() {
    var osc = osc || require_osc();
    try {
      SerialPort = require_dist15();
      require_osc_node_serialport();
    } catch (err) {
      osc.SerialPort = function() {
        throw new Error("The Node.js SerialPort library is not installed. osc.js' serial transport is unavailable.");
      };
    }
    var SerialPort;
  }
});

// node_modules/osc/src/platforms/osc-node.js
var require_osc_node = __commonJS({
  "node_modules/osc/src/platforms/osc-node.js"(exports, module) {
    (function() {
      "use strict";
      var shallowMerge = function(target, toMerge) {
        target = target || {};
        if (toMerge.forEach === void 0) {
          toMerge = [toMerge];
        }
        toMerge.forEach(function(obj) {
          for (var prop in obj) {
            target[prop] = obj[prop];
          }
        });
        return target;
      };
      var dgram = require_dgram(), net = require_net(), WebSocket2 = require_browser(), modules = [
        require_osc(),
        require_osc_transports(),
        require_osc_websocket_client(),
        require_osc_node_serialport_loader()
      ], osc = shallowMerge({}, modules);
      osc.UDPPort = function(options) {
        osc.Port.call(this, options);
        this.options.localAddress = this.options.localAddress || "127.0.0.1";
        this.options.localPort = this.options.localPort !== void 0 ? this.options.localPort : 57121;
        this.options.remoteAddress = this.options.remoteAddress || "127.0.0.1";
        this.options.remotePort = this.options.remotePort !== void 0 ? this.options.remotePort : 57121;
        this.on("open", this.listen.bind(this));
        this.socket = options.socket;
        if (this.socket) {
          this.emit("open", this.socket);
        }
      };
      var p = osc.UDPPort.prototype = Object.create(osc.Port.prototype);
      p.constructor = osc.UDPPort;
      p.open = function() {
        var that = this;
        if (this.socket) {
          return;
        }
        this.socket = dgram.createSocket("udp4");
        this.socket.on("error", function(error) {
          that.emit("error", error);
        });
        function onBound() {
          osc.UDPPort.setupMulticast(that);
          if (that.options.broadcast) {
            that.socket.setBroadcast(that.options.broadcast);
          }
          that.emit("open", that.socket);
        }
        this.socket.bind(this.options.localPort, this.options.localAddress, onBound);
      };
      p.listen = function() {
        if (!this.socket) {
          return;
        }
        var that = this;
        this.socket.on("message", function(msg, rinfo) {
          that.emit("data", msg, rinfo);
        });
        this.socket.on("close", function() {
          that.emit("close");
        });
        that.emit("ready");
      };
      p.sendRaw = function(encoded, address, port) {
        if (!this.socket) {
          osc.fireClosedPortSendError(this);
          return;
        }
        var length = encoded.byteLength !== void 0 ? encoded.byteLength : encoded.length, that = this;
        address = address || this.options.remoteAddress;
        port = port !== void 0 ? port : this.options.remotePort;
        this.socket.send(encoded, 0, length, port, address, function(err) {
          if (err) {
            that.emit("error", err);
          }
        });
      };
      p.close = function() {
        if (this.socket) {
          this.socket.close();
        }
      };
      osc.UDPPort.setupMulticast = function(that) {
        if (that.options.multicastTTL !== void 0) {
          that.socket.setMulticastTTL(that.options.multicastTTL);
        }
        if (that.options.multicastMembership) {
          if (typeof that.options.multicastMembership === "string") {
            that.options.multicastMembership = [that.options.multicastMembership];
          }
          that.options.multicastMembership.forEach(function(addr) {
            if (typeof addr === "string") {
              that.socket.addMembership(addr);
            } else {
              that.socket.addMembership(addr.address, addr.interface);
            }
          });
        }
      };
      osc.TCPSocketPort = function(options) {
        osc.SLIPPort.call(this, options);
        var o = this.options;
        o.address = o.address || o.localAddress || "127.0.0.1";
        o.port = o.port !== void 0 ? o.port : o.localPort !== void 0 ? o.localPort : 57121;
        this.on("open", this.listen.bind(this));
        this.socket = options.socket;
        if (this.socket) {
          this.emit("open", this.socket);
        }
      };
      p = osc.TCPSocketPort.prototype = Object.create(osc.SLIPPort.prototype);
      p.constructor = osc.TCPSocketPort;
      p.open = function(address, port) {
        var o = this.options;
        address = address || o.address;
        port = port !== void 0 ? port : o.port;
        if (!this.socket) {
          this.socket = net.connect({
            port,
            host: address
          });
        } else {
          this.socket.connect(port, address);
        }
        this.emit("open", this.socket);
      };
      p.listen = function() {
        var that = this;
        this.socket.on("data", function(msg) {
          that.emit("data", msg, void 0);
        });
        this.socket.on("error", function(err) {
          that.emit("error", err);
        });
        this.socket.on("close", function(hadError) {
          that.emit("close", hadError);
        });
        this.socket.on("connect", function() {
          that.emit("ready");
        });
      };
      p.sendRaw = function(encoded) {
        if (!this.socket) {
          return;
        }
        encoded = Buffer.from(encoded);
        try {
          this.socket.write(encoded);
        } catch (err) {
          this.emit("error", err);
        }
      };
      p.close = function() {
        this.socket.end();
      };
      module.exports = osc;
    })();
  }
});
export default require_osc_node();
//# sourceMappingURL=osc.js.map
